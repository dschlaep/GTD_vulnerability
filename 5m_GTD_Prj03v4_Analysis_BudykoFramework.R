################### COMPARE RESULTS AGAINST BUDYKO FRAMEWORK ########
#
# Daniel Schlaepfer, 2015-2016
# 
# Compare simulation results against Budyko framework. Fit current values to Fuh's equation
# to estimate omega for each region.
#	- requests 'get_precalculations' from '5a1_GTD_*.R'
#	- requests 'get_studyareaextents' from '5a1_GTD_*.R'
#
###################################################################


#---GLOBAL SETTINGS
comp <- "dropbox"
do_budyko <- TRUE
redo_budyko <- FALSE

#-------------------------------
#---R packages
pkg_reqd <- c("RColorBrewer")
has_loaded <- sapply(pkg_reqd,
	function(lib) require(lib, character.only = TRUE, quietly = FALSE))
stopifnot(has_loaded)

#---Load data and misc. functions
if (comp %in% c("err", "eleos")) {
	dir.gtd <- "/PATH_TO_PROJECT/Product_PowellCenter/6_Projects_Year1"
} else if (comp == "dropbox") {
	dir.gtd <- "/PATH_TO_PROJECT/Product_PowellCenter/6_Projects_Year1"
}
dir.prj <- file.path(dir.gtd, "Prj03_GlobalVulnerability", "4_Analysis", "4_Analysis_v4")


get_precalculations <- TRUE
get_studyareaextents <- TRUE
source(file.path(dir.prj, "5a1_GTD_Prj03v4_Helper.R"))

stopifnot(done_precalculations, done_studyareaextents)


#---Directories
dir.create(dir.out_SAM <- file.path(dir.prj, "6_Results", "12_Budyko_Framework"), showWarnings = FALSE)


#-------------------------------
#------TABLES AND FIGURES

if (do_budyko) {

  budyko_curve <- compiler::cmpfun(function(AIb = seq(0, 4, length = 100), omega = 2.6) {
    # Greve, P., Gudmundsson, L., Orlowsky, B. & Seneviratne, S.I. (2015). Introducing a probabilistic Budyko framework. Geophys Res Lett, 42, 2261-2269.
    # Fuh, B.-p. (1981). On the calculation of the evaporation from land surface [in Chinese]. Sci Atmos Sin, 5, 23-31.
    # Zhang, L., Hickel, K., Dawes, W.R., Chiew, F.H.S., Western, A.W. & Briggs, P.R. (2004). A rational function approach for estimating mean annual evapotranspiration. Water Resour Res, 40, n/a-n/a.
    if (omega >=  1) {
      AIb <- ifelse(AIb >=  0, AIb, NA)
      temp <- 1 + AIb - (1 + AIb ^ omega) ^ (1 / omega) # F = E(actual) / P; AIb = E(potential) / P
      ifelse(is.finite(temp), temp, 1)

    } else {
      rep(NA, length(AIb))
    }
  })
  
  objective_budyko_omega <- compiler::cmpfun(function(omega, AIb, F) {
    # approach suggested for annual data by: Li, D., Pan, M., Cong, Z., Zhang, L. & Wood, E. (2013). Vegetation control on water and energy balance within the Budyko framework. Water Resour Res, 49, 969-976.
    #    = > "minimizes the mean squared errors between the Budyko modeled annual evaporation ratios (E/P) and the measured ones"
    # approach applied for annual data by: Greve, P., Gudmundsson, L., Orlowsky, B. & Seneviratne, S.I. (2015). Introducing a probabilistic Budyko framework. Geophys Res Lett, 42, 2261-2269.
    sum((F - budyko_curve(AIb, omega)) ^ 2)
  })

  optimize_budyko_omega <- function(AIb, F) {
  	dat <- cbind(AIb, F)
  	dat <- dat[complete.cases(dat), ]
  	
    stats::optimize(objective_budyko_omega, interval = c(1, 20), AIb = dat[, 1], F = dat[, 2]) # AIb >= 20 <==> AI <= 0.05 Hyperarid (UNEP, Middleton, N. & Thomas, D.S.G. (1997). World atlas of desertification. In. John Wiley. London, New York.)
  }

  estimate_sensitivity_to_AIb <- function(AIb, omega, zeta = 0.1) {
    # Gudmundsson, L., Greve, P. & Seneviratne, S.I. (2016). The sensitivity of water availability to changes in the aridity index and other factors—A probabilistic analysis in the Budyko space. Geophys Res Lett, 43, 6985-6994.
    if (omega >=  1) {
      AIb <- ifelse(AIb >=  0, AIb, NA)
      
      # equation 6 in Gudmundsson et al. 2016
      temp <- 1 - AIb ^ (omega - 1) * (1 + AIb ^ omega) ^ (1 / omega - 1) # F = E(actual) / P; AIb = E(potential) / P
      temp <- abs(temp * zeta * AIb)
      
      ifelse(is.finite(temp), temp, 0)

    } else {
      rep(NA, length(AIb))
    }
  }
        
  add_panel_letter <- function(ip, cex = par("cex"), fig_style. = fig_style) {
    if (fig_style. == "nature") {
      mtext(side = 3, line = -0.5, adj = 0.05, cex = cex, font = 2, text = tolower(letters[ip]))
    } else {
      mtext(side = 3, line = -0.5, adj = 0.05, cex = cex, text = paste0("(", letters[ip], ")"))
    }
  }

  add_loess <- function(x, y, col = "black", lwd = 2, lty = 1) {
    iuse <- complete.cases(cbind(x, y))
    if (sum(iuse) > 0) {
      xt <- seq(quantile(x[iuse], probs = 0.025, na.rm = TRUE),
              quantile(x[iuse], probs = 0.975, na.rm = TRUE),
              length.out = 100)
      try({
        y_pred <- predict(loess(y ~ x), newdata = data.frame(x = xt))
        lines(xt, y_pred, col = col, lwd = lwd, lty = lty, lend = 1)
      }, silent = TRUE)
    }
  }


	compare_with_budyko_v2 <- function(varnameX, labelX, datX, xlim, varnameY, labelY, datY, dir_out, add_clouds = FALSE, estimate_budyko = TRUE, add_sensitivity = TRUE) {

		ftagX <- clean_name(varnameX)
		ftagY <- clean_name(varnameY)

		# colors
		col_regions <- brewer.pal(5, "Set2")
		colF <- adjustcolor("gray40", alpha.f = 0.4)
		colL <- adjustcolor("black", alpha.f = 0.4)
		icol <- "#FF006080"
	
		#------Data
		ydata <- lapply(change_types[1:2], function(type)
		  dat_sweep(datY, datY["Simulation", currentSc, currentSc, ], type, circular = grepl("_doy", varnameY)))
		names(ydata) <- change_types[1:2]
		dxdata <- dat_sweep(datX, datX["Simulation", currentSc, currentSc, ], "AbsoluteChange", circular = grepl("_doy", varnameX))
		
		#------Figures
    temp <- strsplit(labelX, "AIb", fixed = TRUE)[[1]]
    temp <- paste0(temp, collapse = 'AI[b], \"')
    temp <- strsplit(temp, "E(potential)", fixed = TRUE)[[1]]
    temp <- paste0(temp, collapse = '\", E[potential], \"')
    xlab <- parse(text = paste0('paste(', temp, '\")'))
    
    temp <- strsplit(labelY, "E(actual)", fixed = TRUE)[[1]]
    temp <- paste0(temp, collapse = '\", E[actual], \"')
    ylab1 <- parse(text = paste0('paste(\"', temp, '\")'))

    temp <- strsplit(labelY, " = ", fixed = TRUE)[[1]][1]
    ylab2 <- bquote(group("|",
                          frac(.(temp)[current] - .(temp)[future], AI[list(b, current)] - AI[list(b, future)])
                          ~~ zeta ~~ AI[b], "|"))

		for (ircp in seq_along(reqRCPs)) {
			fname <- paste0("Fig_Budyko_", reqRCPs[ircp],
			                if (add_clouds) "_withDataCloud",
			                if (estimate_budyko) "_withBudyko",
			                if (add_sensitivity) "_withSensitivity",
			                "_v2.pdf")
			ftemp <- file.path(dir_out, fname)

			if (redo_budyko || !file.exists(ftemp)) {
				pdf(height = 3 * (if (add_sensitivity) 2 else 1), width = 4, file = ftemp)
				par_old <- par(mfrow = c(if (add_sensitivity) 2 else 1, 1),
				              mgp = c(1.25, 0.25, 0),
				              mar = c(if (add_sensitivity) 0.65 else 2.75, 3.5, 0.35, 0.35),
				              tcl = 0.3, las = 1, cex = cex <- 1, xpd = FALSE)
	      on.exit(par(par_old))
	      
				if (is.null(xlim))
					xlim <- range(datX["MetDef_Any17Cond", reqRCPs[ircp], currentSc, ], na.rm = TRUE)
				ylim <- lapply(ydata, function(dat) quantile(dat["MetDef_Any17Cond", reqRCPs[ircp], , ], probs = c(0.005, 0.995), na.rm = TRUE))
				ylim[[1]] <- c(0, 1)
				ylim[[2]] <- c(0, 0.06)
				
				#--- panel a: F versus AI of current data
				plot(1, col = "white",
					xlim = xlim, ylim = ylim[[1]],
					xlab = if (!add_sensitivity) xlab else "", ylab = ylab1,
					axes = FALSE)
				axis(1, pos = ylim[[2]][1], labels = !add_sensitivity)
				axis(2, pos = xlim[1])
        
        if (add_sensitivity)
          add_panel_letter(1, cex)
				
        # Extract data
				rdat <- list()
				for (i in seq_along(regions_n)) {
					ids <- dLoc[, "Region"] %in% regions_n[i]
					rdat[[i]] <- list()
					rdat[[i]][["x"]] <- datX["MetDef_ThisCond", currentSc, currentSc, ids]
					rdat[[i]][["y"]] <- ydata[["Mean"]]["MetDef_ThisCond", currentSc, currentSc, ids]
		
          # Add 90% data clouds				
					if (add_clouds)
					  try(draw.contourCIpoints(x = rdat[[i]][["x"]], y = rdat[[i]][["y"]], alpha = 0.90,
						  	col = col_regions[i],
							  fill = TRUE, na.rm = TRUE, lwd = 3))
				}

        # Draw smoothed line through data
				for (i in seq_along(regions_n)) {          
          add_loess(rdat[[i]][["x"]], rdat[[i]][["y"]], col = adjustcolor(col_regions[i], alpha.f = 0.8), lwd = 3)
				}

				# Estimate Budyko curve
        xt <- seq(xlim[1], xlim[2], length = 100)

        if (estimate_budyko) {
          romega <- data.frame(
            Region = label.regions[regions_n],
            omega = NA,
            RMSE = NA)

          for (i in seq_along(regions_n)) {          
            # Estimate Budyko omega
            omega <- optimize_budyko_omega(rdat[[i]][["x"]], rdat[[i]][["y"]])
            romega[i, "omega"] <- omega$minimum
            romega[i, "RMSE"] <- sqrt(omega$objective / length(rdat[[i]][["y"]]))
        
            # Draw Budyko curve
            F_pred <- budyko_curve(AIb = xt, omega = omega$minimum)
            lines(xt, F_pred, col = "black", lwd = 1)
            lines(xt, F_pred, col = adjustcolor(col_regions[i], alpha.f = 0.8), lwd = 2, lty = 2)
          }

          # Print estimates of omega
          legs <- c(list(head = expression(omega %+-% "RMSE")),
              as.list(apply(romega, 1, function(x)
                paste0(x[1], ": ",
                      formatC(as.numeric(x[2]), format = "f", digits = 2), " ± ",
                      formatC(as.numeric(x[3]), format = "f", digits = 2)))))
          cumh_legs <- rev(cumsum(sapply(legs, function(l) 1.5 * strheight(l))))
          temp <- lapply(rev(seq_along(legs)), function(l)
            text(x = xlim[2], y = ylim[[1]][1] + cumh_legs[l], adj = c(1, 0),
                 labels = legs[[l]], cex = cex, xpd = NA))
        }
        				
				# Draw limiting Budyko curve
				F_pred <- budyko_curve(AIb = xt, omega = .Machine$double.xmax)
				lines(xt, F_pred, col = "black", lwd = 2)
				
					
				#--- panel b: abs(delta(F)) versus AI of current data
				if (add_sensitivity) {
          par(mar = c(2.75, 3.5, 0.35, 0.35))
          zeta <- 0.1 # Gudmundsson, L., Greve, P. & Seneviratne, S.I. (2016). The sensitivity of water availability to changes in the aridity index and other factors—A probabilistic analysis in the Budyko space. Geophys Res Lett, 43, 6985-6994.
        
          plot(1, col = "white",
            xlim = xlim, ylim = ylim[[2]],
            xlab = xlab, ylab = "",
            axes = FALSE)
          axis(side = 1, pos = ylim[[2]][1])
          axis(side = 2, pos = xlim[1])
          mtext(side = 2, text = ylab2, line = 1.25, cex = 0.8 * cex, las = 3)

          add_panel_letter(2, cex)
        
          # Extract data
          rdat <- list()
          for (i in seq_along(regions_n)) {
            ids <- dLoc[, "Region"] %in% regions_n[i]
            rdat[[i]] <- list()
            rdat[[i]][["x"]] <- datX["MetDef_Any17Cond", reqRCPs[ircp], currentSc, ids]
            rdat[[i]][["y"]] <- list()
          
            for (igcm in seq_along(reqGCMs)) {
              dy <- ydata[["AbsoluteChange"]]["MetDef_ThisCond", reqRCPs[ircp], reqGCMs[igcm], ids]
              dx <- dxdata["MetDef_ThisCond", reqRCPs[ircp], reqGCMs[igcm], ids]

              dF_to_dAIb_obs <- ifelse(abs(dx) > 0.1 & abs(dx) < 10,
                                       abs(dy / dx * zeta * rdat[[i]][["x"]]),
                                       NA)
              rdat[[i]][["y"]][[reqGCMs[igcm]]] <- dF_to_dAIb_obs

              # Add 90% data clouds				
              if (add_clouds)
                try(draw.contourCIpoints(x = rdat[[i]][["x"]], y = rdat[[i]][["y"]][[reqGCMs[igcm]]], alpha = 0.90,
                    col = adjustcolor(col_regions[i], alpha.f = 1 / length(reqGCMs)),
                    fill = TRUE, na.rm = TRUE))
            }
          }

          # Add smoothed lines through data
          for (i in seq_along(regions_n)) {
            for (igcm in seq_along(reqGCMs)) {
              add_loess(rdat[[i]][["x"]], rdat[[i]][["y"]][[reqGCMs[igcm]]],
                        col = adjustcolor(col_regions[i], alpha.f = 0.8))
            }
          }

          # Draw Budyko sensitivity curve
          if (estimate_budyko) {
            for (i in seq_along(regions_n)) {
              # Estimate Budyko sensitivity
              dF_to_dAIb_est <- estimate_sensitivity_to_AIb(
                AIb = xt,
                omega = romega[i, "omega"],
                zeta = zeta)
            
              # Draw Budyko curve
              lines(xt, dF_to_dAIb_est, col = "black", lwd = 1)
              lines(xt, dF_to_dAIb_est, col = adjustcolor(col_regions[i], alpha.f = 0.8), lwd = 2, lty = 2)
            }
          }

          # Zero line
  #				segments(x0 = min(xlim), y0 = 0, x1 = max(xlim), col = "gray20")
        
          # Legend
          if (!identical(fig_style, "nature"))
            legend(x = "topright", inset = c(0.05, 0), bty = "n", ncol = 1,
                   legend = label.regions[regions_n],
                   lwd = 2, col = col_regions, pt.cex = 1.4, cex = cex, xpd = NA)
        }
        
				dev.off()
			}
		}		

		invisible(NULL)
	}


	print("DrylandResponse: comparison with the Budyko framework")
		
  varX <- "AI_budyko_Normals_none" # aridity index AIb = E(potential) / P
  varY <- "AETtoMAP_mean"          # F = E(actual) / P
	
	des <- expand.grid(
	  add_clouds = c(TRUE, FALSE),
    estimate_budyko = c(TRUE, FALSE),
    add_sensitivity = c(TRUE, FALSE))
	
	for (k in seq_len(nrow(des)))  
    compare_with_budyko_v2(
        varnameX = varX,
        labelX = label_budyko[var_budyko ==  varX],
        datX = resBudyko2[, , , , varX], 
        xlim = c(0, 10),
        varnameY = varY,
        labelY = label_budyko[var_budyko ==  varY], 
        datY = resBudyko2[, , , , varY],
        dir_out = dir.out_SAM,
        add_clouds = des[k, "add_clouds"],
        estimate_budyko = des[k, "estimate_budyko"],
        add_sensitivity = des[k, "add_sensitivity"])
	
}

