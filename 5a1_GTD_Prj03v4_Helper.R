################### SETTINGS, FUNCTIONS, and DATA ##################
#
# Daniel Schlaepfer, 2015-2016
# 
# Collection of settings, functions, and (pre-extracted) data loading
# Scripts '5a2_GTD_*.R' and '5a3_GTD_*.R' must be run before data can be loaded with this script
#	- 'done_XXX' flags must be stored by those scripts
#	- 'get_XXX' flags must be set by scripts before calling this helper script to load the data XXX

# Define study area by three criteria
#	1. Aridity: PPT/PET < 0.5 [< 0.05, hyper-arid; < 0.2, arid; < 0.5, semi-arid; <0.65, dry-subhumid; >= 0.65, humid]
#	2. Temperateness: Trewartha's D
#	3. Contiguousness: Contiguous with areas matching criteria 1 & 2 under current conditions
# Cells included in simulations: "Mask_Current" == 1 || "Mask_Future" == 1
#	- "Mask_Current": based on preliminary simulation for 1979-2010
#	- "Mask_Future": most severely dry & hot future
# --> for each climate scenario, check which cells are included in study area of the climate scenario

# study_areas_all, study_areas_v4:
#	- We simulated about 20,000 cells (study_areas_all == "Simulation"). Not all of these cells are temperate drylands by our climatological definition (aridity & temperateness, see above).
#	- Each simulated climate scenario (current, 16 GCMs x 2 RCPs) has a different extent of temperate dryland cells (study_areas_v4 == "MetDef_ThisCond") because of using a climatological definition.
# 	- We summarized the possible temperate dryland extent by considering cells that meet the climatological definition for either current or one of the 16 GCMs per RCP (study_areas_v4 == "MetDef_Any17Cond"). Note: dStudy["MetDef_Any17Cond", currentSc, , ] contains only NAs because "MetDef_Any17Cond" is specific to a RCP. The current information for the summary "MetDef_Any17Cond" can instead be found in dStudy["MetDef_Any17Cond", RCP, currentSc, ].

# Shifting zones: We identified three shifting zones for each GCM: (i) contracting (temperate dryland under current, but not under future climate condition); (ii) stable (temperate dryland under current and future conditions); (iii) expanding (temperate dryland under future, but not current conditions).

# Ranks: For each cell and RCP, we simulated the water balance 16 times (input from 16 GCMs to SOILWAT). To summarize results, we ranked the 16 results by value and considered the 8th largest value (i.e., at rank 8) as the median estimate. We estimated the range of variation among the 16 replicate simulation runs per cell and RCP as the difference between the smallest and largest of the 16 values (i.e., at rank 1 and 16).

###################################################################


#---GLOBAL SETTINGS
comp <- "dropbox"
fig_style <- "nature"
do_spatialinterpolation <- FALSE


#-------------------------------
#---R packages
pkg_reqd <- c("raster", "ncdf4", "rgdal", "maps", "reshape2")
has_loaded <- sapply(pkg_reqd,
	function(lib) require(lib, character.only = TRUE, quietly = FALSE))
stopifnot(has_loaded)

#---Directories
if (comp %in% c("err", "eleos")) {
	dir.gtd <- "/PATH_TO_PROJECT/Product_PowellCenter/6_Projects_Year1"
} else if (comp == "dropbox") {
	dir.gtd <- "/PATH_TO_PROJECT/Product_PowellCenter/6_Projects_Year1"
}

dir.sim <- file.path(dir.gtd, "Prj03_GlobalVulnerability", "1_PC_TempDry_Simulations_Prj03_r2")
dir.sim_out <- file.path(dir.sim, "4_Data_SWOutputAggregated", "DATA_v4")

dir.sana <- file.path(dir.gtd, "GTD_SharedAnalysis")
dir.gis <- file.path(dir.sana, "1_GISdata")


#---File names
name.dbScen <- "dbTables_exp01.sqlite3"
tag_dbScen <- strsplit(name.dbScen, split = ".", fixed = TRUE)[[1]][1]



#---Check which data are available from future code
if (file.exists(ftemp <- file.path(dir.sim_out, paste0("Flag_DataExtraction_", tag_dbScen, ".rds")))) {
	done_data_extraction <- readRDS(ftemp)
} else {
	done_data_extraction <- FALSE
}
if (done_data_extraction && file.exists(ftemp <- file.path(dir.sim_out, paste0("Flag_PreCalculations_", tag_dbScen, ".rds")))) {
	done_precalculations <- readRDS(ftemp)
} else {
	done_precalculations <- FALSE
}
if (file.exists(ftemp <- file.path(dir.sim_out, paste0("Flag_StudyAreaExtents_", tag_dbScen, ".rds")))) {
	done_studyareaextents <- readRDS(ftemp)
} else {
	done_studyareaextents <- FALSE
}

#---Determine which data object to load from disk
do1 <- done_data_extraction && if (exists("get_data_extraction")) get_data_extraction else FALSE
do2 <- done_precalculations && if (exists("get_precalculations")) get_precalculations else FALSE
do3 <- done_studyareaextents && if (exists("get_studyareaextents")) get_studyareaextents else FALSE


#---Study area definition:
var.Study <- "TemperateDryland12_Normals_TF_mean"


#---GIS MAPPING
WGS84 <- raster::crs("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")


#---Settings: Simulation
currentSc <- "Current"
#ranks <- c(2, 8, 15)
ranks <- c(1, 8, 16) #20150626: John, Bill, and I decided to use entire range of GCMs
ranks_rev <- c(1, 9, 16)
rank.labels <- c("1st", "8th", "16th")
ie <- 1
layerDepths_cm <- c(0, 10, 20, 40, 60, 80, 100, 150, 200, 250)
depthTopBottomLayers_cm <- 20
regions_N <- 1:6
label.regions <- c("South America", "Southern Africa", "Eastern Asia", "Western & Central Asia", "Western Mediterranean", "North America")
vegtypes <- c("Shrub", "Grass", "Tree")
mo <- 1:12
doy <- 1:365
startyr <- 1979 + 1
endyr <- 2010
nruns <- endyr - startyr + 1

#---Settings: Analysis
shifts <- c("trailing", "stable", "leading")
shifts_code <- c(-1, 0, 1)
cols_shifts <- c("orange", "gray40", "blue")

omit_SouthAfrica <- TRUE
regions_n <- if (omit_SouthAfrica) regions_N[-2] else regions_N

study_areas_v4 <- c("MetDef_Any17Cond", "MetDef_ThisCond")
# note: "MetDef_Any17Cond" is specific to RCPs; hence dStudy["MetDef_Any17Cond", currentSc, , ] has no information, it can be found in dStudy["MetDef_Any17Cond", , currentSc, ] instead
study_areas_all <- c("Simulation", study_areas_v4)
stopifnot(study_areas_all[1] == "Simulation")

study_areas_and_shifts <- c(study_areas_v4, shifts)

change_types <- c("Mean", "AbsoluteChange", "RelativeChange")

sets_names_extracted <- c("resClimate", "resResponse", "resDefinition", "resSoils", "resVeg", "resPPT", "resTempAir", "resVWC", "resTransp", "resBudyko")
sa_names_def2 <- c("dStudy2", "dShift2")
sa_names_rankpercell2 <- paste0(sa_names_def2, "_rankpercell")
sets_names_extracted2 <- paste0(sets_names_extracted, 2)
sets_names_cor2 <- paste0(sets_names_extracted2, "_corAI")
sets_names_rankpercell2 <- paste0(sets_names_extracted2, "_rankpercell")


#-------------------------------
#------LOAD DATA ORIGINATING FROM RUNNING 5a2_GTD_Prj03v2_Extract_subsetPrj06.R

if (do1 || do2) {
	#---Design of simulation experiment
	#load: scenarios, climScen, reqGCMs, reqRCPs, rcp_gcm, reqGCMs_wCur, reqRCPs_wCur
	load(file.path(dir.sim_out, "Extraction", paste0("Scenarios_", tag_dbScen, ".RData")))

	#load: trNames_Experiment, TreatmentDefinitions, trLevels_Site, trLevels_Region, trLevels_Experiment
	load(file.path(dir.sim_out, "Extraction", paste0("Experiment_", tag_dbScen, ".RData"))) 

	#load: dbScen.Tables, dbScen.OverallFields
	load(file.path(dir.sim_out, "Extraction", paste0("TablesFields_", tag_dbScen, ".RData")))

	#load: var_definition, var_climate, var_response, var_soils, label_definition, label_climate, label_response, label_soils
	load(file.path(dir.sim_out, "Extraction", paste0("ExtractedVariables_", tag_dbScen, ".RData")))
	sets_labels_extracted <- lapply(sets_names_extracted, function(x) get(paste0("label_", tolower(substr(x, 4, nchar(x))))))
	
	#define subsets of variables
	var_response_sel <- c("TmaxAbovePos34degC_days",
							"ThermalSnowfreeDryPeriods_SWPcrit3000kPa_topLayers_DrySpellsAllLayers_maxDuration_days", "ThermalSnowfreeDryPeriods_SWPcrit3000kPa_bottomLayers_DrySpellsAllLayers_maxDuration_days",
							"DrySoilPeriods_SWPcrit1500kPa_MissingWater_allLayers_AnnualSum_m",
							"ThermalSnowfreeDryPeriods_SWPcrit3000kPa_topLayers_DrySpellsAtLeast10DaysAllLayers_Start_doy", "ThermalSnowfreeDryPeriods_SWPcrit3000kPa_bottomLayers_DrySpellsAtLeast10DaysAllLayers_Start_doy",
							"TeeriEtAl1976_NSadj_FreezeFreeGrowingPeriod_days",
							"WetSoilPeriods_SWPcrit1500kPa_NSadj_topLayers_AllLayersWet_Duration_Total_days", "WetSoilPeriods_SWPcrit1500kPa_NSadj_bottomLayers_AllLayersWet_Duration_Total_days",
							"ThermalSnowfreeWetPeriods_SWPcrit1500kPa_allLayers_AvailableWater_m",
							"TranspirationBottomToTranspirationTotal_fraction", "TtoAET"
						)
	label_response_sel <- c("Hot days (>34 C days)",
							"Ecological drought duration 0-20 cm (days)", "Ecological drought duration >20 cm (days)",
							"Missing water (m H2O)",
							"GP drought onset 0-20 cm (DOY)", "GP drought onset >20 cm (DOY)",
							"Growing season GP (days)",
							"Wet days 0-20 cm (days)", "Wet days >20 cm (days)",
							"GP available water (m H2O)",
							"Tdeep / Ttotal (-)", "T/AET (-)"
						)
	

	#load: dLoc
	load(file.path(dir.sim_out, "Extraction", paste0("dLoc_", tag_dbScen, ".RData")))
}


if (do1) {
	#load: dStudy
	load(file.path(dir.sim_out, "Extraction", paste0("dStudy_", tag_dbScen, ".RData")))

	#---Load extracted response data
	lapply(sets_names_extracted, function(x) load(file.path(dir.sim_out, "Extraction", paste0(x, "_", tag_dbScen, ".RData")), envir = .GlobalEnv))

	#check that reqRCPs and reqGCMs in correct order
	temp <- lapply(sets_names_extracted, function(x) {
					temp <- dimnames(get(x))
					stopifnot(reqRCPs == temp[[2]][-1])
					stopifnot(reqGCMs == temp[[3]][-1])
			})
}


#------LOAD DATA ORIGINATING FROM RUNNING 5a3_GTD_Prj03v2_PreCalculations.R
if (do2) {
	#---Load extracted study area, response data, correlation with AI, and ranks only of study area
	lapply(c(sa_names_def2, sa_names_rankpercell2, sets_names_extracted2, sets_names_cor2), function(x) load(file.path(dir.sim_out, "PreCalculations", paste0(x, "_", tag_dbScen, ".RData")), envir = .GlobalEnv))
	#lapply(c(sets_names_rankpercell2), function(x) load(file.path(dir.sim_out, "PreCalculations", paste0(x, "_", tag_dbScen, ".RData")), envir = .GlobalEnv))

	#check that reqRCPs and reqGCMs in correct order
	temp <- lapply(c("dStudy2", sets_names_extracted2), function(x) {
					temp <- dimnames(get(x))
					stopifnot(reqRCPs == temp[[2]][-1])
					stopifnot(reqGCMs == temp[[3]][-1])
			})
	temp <- lapply("dShift2", function(x) {
					temp <- dimnames(get(x))
					stopifnot(reqRCPs == temp[[1]])
					stopifnot(reqGCMs == temp[[2]])
			})
	temp <- lapply(sets_names_cor2, function(x) {
					temp <- dimnames(get(x)$tau)
					stopifnot(reqRCPs == temp[[2]][-1])
					stopifnot(reqGCMs == temp[[3]][-1])
			})

	#load: raster mask
	mask_Any17Cond <- list()
	for (ircp in seq_along(reqRCPs)) {
		mask_Any17Cond[[reqRCPs[ircp]]] <- raster(file.path(dir.gis, "Any17Cond", paste0("StudyAreaMask_Any17Cond_", reqRCPs[ircp], ".asc")))
		projection(mask_Any17Cond[[reqRCPs[ircp]]]) <- WGS84
	}
	
	mask_simulation <- raster(file.path(dir.gis, "CurrentFuture", "StudyAreaMask_CurrentFuture.asc"))
	projection(mask_simulation) <- WGS84
}

#------LOAD DATA ORIGINATING FROM RUNNING 5b_GTD_Prj03v2_Analysis_StudyArea.R
if (do3) {
	#load: resExtent2
	load(file.path(dir.sim_out, "StudyArea_Extent", paste0("resExtent2_", tag_dbScen, ".RData")))

	#load: resExtent2_ranks
	#load(file.path(dir.sim_out, "StudyArea_Extent", paste0("resExtent2_ranks_", tag_dbScen, ".RData")))
}


#-------------------------------
#---FUNCTIONS

#-------------------------------
#-Calculating stuff

#Circular functions: int = number of units in circle, e.g., for days: int = 365; for months: int = 12
circ.mean <- function(x, int, na.rm = FALSE) {
	if (length(x) == sum(is.na(x)))
		return(NA)
	
	circ <- 2 * pi / int
	x.circ <- circular::circular(x * circ, type = "angles", units = "radians", rotation = "clock", modulo = "2pi")
	res <- circular::mean.circular(x.circ, na.rm = na.rm) / circ
	
	round(as.numeric(res) - 1, 13) %% int + 1	# map 0 -> int; rounding to 13 digits: 13 was empirically derived for int = {12, 365} and x = c((-1):2, seq(x-5, x+5, by = 1), seq(2*x-5, 2*x+5, by = 1)) assuming that this function will never need to calculate for x > t*int with t>2
}

circ.median <- function(x, int, na.rm = FALSE) { #Definition in equations 2.32 & 2.33 from N.I. Fisher's 'Statistical Analysis of Circular Data', Cambridge Univ. Press 1993
	if (length(x) == sum(is.na(x)))
		return(NA)

	circ <- 2 * pi / int
	x.circ <- circular::circular(x * circ, type = "angles", units = "radians", rotation = "clock", modulo = "2pi")
	res <- circular::median.circular(x.circ, na.rm = na.rm) / circ
	
	as.numeric(res)
}

circ.quantile <- function(x, int, modulo = c("asis", "2pi"), probs = seq(0, 1, 0.25), na.rm = FALSE, names = FALSE, type = 7, ...) {
	if (length(x) == sum(is.na(x))) {
		return(NA)

	module <- match.arg(modulo)
	
	circ <- 2 * pi / int
	x.circ <- circular::circular(x * circ, type = "angles", units = "radians", rotation = "counter", modulo = modulo) # 20150715: the function quantile.circular() operates internally with rotation = "counter"; if we use here rotation = "clock", then we get flipped values
	res <- circular::minusPiPlusPi(circular::quantile.circular(x.circ, probs = probs, na.rm = na.rm, names = names, type = type, ...)) / circ

	as.numeric(res)
}


circ.scale <- function(x, int, na.rm = FALSE) {
	if (length(x) == sum(is.na(x)))
		return(NA)

	warning("Not clear whether this is the correct way to scale circular data!")		
	#https://en.wikipedia.org/wiki/Directional_statistics: This definition of the standard deviation (rather than the square root of the variance) is useful because for a wrapped normal distribution, it is an estimator of the standard deviation of the underlying normal distribution. It will therefore allow the circular distribution to be standardized as in the linear case, for small values of the standard deviation
	
	center <- circ.mean(x, int = 365, na.rm = TRUE)
	scale <- circ.sd(x, int = 365, na.rm = TRUE) 
	res <- circ.diff(x, center, int = 365) / scale
	
	attr(res, "scaled:center") <- center
	attr(res, "scaled:scale") <- scale

	res
}

circ.diff <- function(x, y, int, na.rm = FALSE) {
	# difference as x - y; positive sign, x is later than y; negative sign, x is earlier than y
	if (length(x) == sum(is.na(x)) && length(y) == sum(is.na(y)))
		return(NA)

	circ <- 2 * pi / int
	res <- circular::circular(circ * (x - y), type = "angles", units = "radians", rotation = "clock", modulo = "asis")
	temp <- na.exclude(res)
	res <- napredict(na.action(temp), circular::minusPiPlusPi(temp) / circ)
	
	as.numeric(res)
}


circ.range <- function(x, int, na.rm = FALSE) {
	if (length(x) == sum(is.na(x)))
		return(NA)

	circ <- 2 * pi / int
	x.circ <- circular::circular(x * circ, type = "angles", units = "radians", rotation = "clock", modulo = "2pi")
	res <- range(x.circ, na.rm = na.rm) / circ
	
	as.numeric(res)
}

circ.sd <- function(x, int, na.rm = FALSE) {
	if (length(x) == sum(is.na(x)) || sum(!is.na(x)) == 1) {
		return(NA)
	} else if (sd(x, na.rm = TRUE) == 0) {
		return(0)
	}
			
	circ <- 2 * pi / int
	x.circ <- circular::circular(x * circ, type = "angles", units = "radians", rotation = "clock", modulo = "2pi")
	res <- circular::sd.circular(x.circ, na.rm = na.rm) / circ
	
	as.numeric(res)
}

# find cells that are TRUE or 1 for any of the 33 climate conditions
get_Any33Cond_v3 <- function(data) {
# str(data): num [1:2, 1:3, 1:17, 1:20021] 1 1 1 NA 1 NA 1 NA 1 1 ...
# - attr(*, "dimnames") = List of 4
# ..$ : chr [1:2] "MetDef_Any33Cond" "MetDef_ThisCond"
# ..$ : chr [1:3] "Current" "RCP45" "RCP85"
# ..$ : chr [1:17] "Current" "CanESM2" "CESM1-CAM5" "CSIRO-Mk3-6-0" ...
# ..$ : NULL
	temp <- ifelse(apply(data["MetDef_ThisCond", , , ], 3, function(x) any(as.logical(x), na.rm = TRUE)), 1, NA)
	
	for (ircp in seq_along(reqRCPs_wCur))
		for (igcm in seq_along(reqGCMs_wCur))
			data["MetDef_Any33Cond", ircp, igcm, ] <- temp
	
	data
}

get_Any17Cond_v4 <- function(data) {
# str(data): num [1:2, 1:3, 1:17, 1:20021] 1 1 1 NA 1 NA 1 NA 1 1 ...
# - attr(*, "dimnames") = List of 4
# ..$ : chr [1:2] "MetDef_Any17Cond" "MetDef_ThisCond"
# ..$ : chr [1:3] "Current" "RCP45" "RCP85"
# ..$ : chr [1:17] "Current" "CanESM2" "CESM1-CAM5" "CSIRO-Mk3-6-0" ...
# ..$ : NULL
	for (ircp in seq_along(reqRCPs)) {
		temp <- ifelse(apply(data["MetDef_ThisCond", c(1, 1 + ircp), , ], 3, function(x) any(as.logical(x), na.rm = TRUE)), 1, NA)
		for (igcm in seq_along(reqGCMs_wCur))
			data["MetDef_Any17Cond", 1 + ircp, igcm, ] <- temp
	}
	
	data
}

# Limit data to study_areas
limit_to_study_area_v4 <- function(data, dStudy) {
# str(data): num [1:3, 1:3, 1:17, 1:20021, 1:nvars] 60 NA NA NA NA NA NA NA NA NA ...
# - attr(*, "dimnames") = List of 5
# ..$ : chr [1:3] "Simulation" "MetDef_Any17Cond" "MetDef_ThisCond"
# ..$ : chr [1:3] "Current" "RCP45" "RCP85"
# ..$ : chr [1:17] "Current" "CanESM2" "CESM1-CAM5" "CSIRO-Mk3-6-0" ...
# ..$ : NULL
# ..$ : chr [1:nvars] vars
	
	stopifnot("Simulation" %in% dimnames(data)[[1]],
				study_areas_v4 %in% dimnames(data)[[1]],
				study_areas_v4 %in% dimnames(dStudy)[[1]])

	vars <- dimnames(data)[[5]]
	for (isa in seq_along(study_areas_v4)) {
		for (iv in seq_along(vars)) {
			data[study_areas_v4[isa], , , , iv] <- sweep(data["Simulation", , , , iv], MARGIN = 1:3, STATS = dStudy[study_areas_v4[isa], , , ], "*")
		}
	}
	
	data
}

# Test that copying of values among study areas and shifting zones worked properly
test_coherence_among_study_areas <- function(data) {
#str(data): num [1:3, 1:3, 1:17, 1:20021, 1:nvars] 0.0312 NA NA NA NA ...
# - attr(*, "dimnames") = List of 5
# ..$ : chr [1:3] "Simulation" "MetDef_Any17Cond" "MetDef_ThisCond"
# ..$ : chr [1:3] "Current" "RCP45" "RCP85"
# ..$ : chr [1:17] "Current" "CanESM2" "CESM1-CAM5" "CSIRO-Mk3-6-0" ...
# ..$ : NULL
# ..$ : chr [1:nvars]
 	
 	temp <- apply(data, MARGIN = 2:length(dim(data)), function(x) if (sum(!is.na(x)) > 1) max(x, na.rm = TRUE) == min(x, na.rm = TRUE) else TRUE)
	
	which(!temp, arr.ind = TRUE) # indices_failed
}

test_coherence_among_study_areas2 <- function(data) {
#str(data): num [1:3, 1:3, 1:17, 1:20021, 1:nvars] 0.0312 NA NA NA NA ...
# - attr(*, "dimnames") = List of 5
# ..$ : chr [1:3] "Simulation" "MetDef_Any17Cond" "MetDef_ThisCond"
# ..$ : chr [1:3] "Current" "RCP45" "RCP85"
# ..$ : chr [1:17] "Current" "CanESM2" "CESM1-CAM5" "CSIRO-Mk3-6-0" ...
# ..$ : NULL
# ..$ : chr [1:nvars]
 	
 	apply(data, MARGIN = 2:length(dim(data)), function(x) if (sum(!is.na(x)) > 1) max(x, na.rm = TRUE) - min(x, na.rm = TRUE) else 0)
}


# Calculate relative or absolute change
dat_sweep <- function(dat, dat_cur, val_type = change_types, circular = FALSE) { #dat_cur should be of "Simulation" extent otherwise only NA values for leading zone 

#str(dat): num [1:5, 1:2, 1:3, 1:20021] NA NA NA NA NA NA NA NA NA NA ...
# - attr(*, "dimnames") = List of 4
# ..$ : chr [1:5] "MetDef_Any17Cond" "MetDef_ThisCond" "trailing" "stable" ...
# ..$ : chr [1:2] "RCP45" "RCP85"
# ..$ : chr [1:3] "1" "8" "16"
# ..$ : NULL
#str(dat_cur): num [1:20021] NA NA NA NA NA NA NA NA NA NA ...

	val_type <- match.arg(val_type)

	if (!(val_type == "Mean")) {
		if (circular) {
			for (isa in 1:dim(dat)[1]) for (ircp in 1:dim(dat)[2]) for (isc in 1:dim(dat)[3]) {
				dat[isa, ircp, isc, ] <- circ.diff(dat[isa, ircp, isc, ], dat_cur, int = 365)
			}
			if (val_type == "RelativeChange") {
				dat <- sweep(dat, MARGIN = 4, STATS = dat_cur, '/') + 1
			}
		} else {
			f <- if (val_type == "AbsoluteChange") '-' else if (val_type == "RelativeChange") '/'
			dat <- sweep(dat, MARGIN = 4, STATS = dat_cur, f)
		}
		if (sum(is.infinite(dat)) > 0) { # e.g., division by 0, e.g., occurring with "resResponse2_ranks ThermalSnowfreeDryPeriods_SWPcrit3000kPa_bottomLayers_DrySpellsAllLayers_maxDuration_days_mean RelativeChange"
			dat[is.infinite(dat)] <- NA
		}
	}
	
	dat
}




# determine variables within data object: sa_names_ranks2/sa_names_rankpercell2 don't have a fifth dimension with response variables
fix_var_dim <- function(data, has_area_dim = TRUE) {
	has_var_dim <- (length(dimnames(data)[5][[1]]) > 0)
	if (has_var_dim) {
		if (!has_area_dim) { #make dShift_XXX-type objects compatible with resXXX-type objects
			vars <- shifts
			resvars <- "none"
		} else { #default case for resXXX-type objects
			vars <- resvars <- dimnames(data)[[5]]
		}
	} else {
		vars <- resvars <- "none"
		dimns <- dimnames(data)
		dim(data) <- c(dim(data), 1) #append a fifth 1-entry dimension to make dStudy-type objects compatible with resXXX-type objects
		dimnames(data) <- modifyList(dimns, list(vars = vars))
	}
	
	list(has_var_dim = has_var_dim, data = data, vars = vars, resvars = resvars)
}


# Extend range by fact
extend_range <- function(x, fact = 1, na.rm = FALSE) {
	x + (fact - 1) * (x - mean(x, na.rm = na.rm))
}


# Calculates the ensemble values as the i-th elements of sorted data given by 'ranks'; NAs are treated as max
# version 1: previous to 2015/08/05
#	calc_ensemble <- function(..., ir = seq_along(ranks), signed = 1) sort(..., decreasing = (signed < 0), na.last = TRUE)[ranks[ir]]
#	Problem: non-coherence of values among study areas and shifts because of NA placement under negative correlation with -AI; e.g., 
#		- "MetDef_Any33Cond": calc_ensemble(x = c(395.49, 394.82, 356.85, 441.75, 541.34, 439.82, 383.2, 371.64, 414.13, 426.27, 386.38, 381.05, 443.31, 349.51, 403.51, 412.74), signed = -1)
#			-> [1] 541.34 403.51 349.51
#		- "MetDef_ThisCond": calc_ensemble(x = c(395.49, 394.82, 356.85, NA, NA, NA, 383.2, 371.64, NA, NA, 386.38, 381.05, NA, 349.51, NA, NA), signed = -1)
#			-> [1] 395.49 349.51   NA
#			 ==> value of ranks[3] under "MetDef_Any33Cond" was moved to ranks[2] under "MetDef_ThisCond" because of na.last = TRUE

# version 2:
#	Issue: coherence of values among study areas and shifts assumes that GCMs drop out from being included as study area in order of increasing/decreasing values. This is only true if correlation among study area criteria and response variable under consideration is one of {-1, 1}. Otherwise, there will be GCMs with a lower value than say rank 8 at "MetDef_Any33Cond", but they will drop out under "MetDef_ThisCond" or one of the shifting zones and hence the value at rank 8 changes. This can happen at any rank; e.g., 
#		- "MetDef_Any33Cond": calc_ensemble(x = c(329.35, 306.22, 297.51, 319.63, 203.79, 340.6, 486.93, 264.8, 639.35, 530.43, 214.23, 153.31, 243.44, 264.64, 293.49, 349.83), signed = -1)
#			-> [1] 639.35 297.51 153.31
#		- "trailing": calc_ensemble(x = c(NA, NA, NA, NA, NA, NA, NA, NA, 639.35, NA, NA, NA, NA, NA, NA, NA), signed = -1)
#			-> [1]   NA   NA 639.35

#	 ==> coherence of values among study areas and shifts cannot be absolute, but only approximative (corresponding to the correlation coefficient)

if (FALSE) {
	# Ensemble functions
	calc_ensemble1 <- function(..., ir = seq_along(ranks), signed = 1) sort(..., decreasing = (signed < 0), na.last = TRUE)[ranks[ir]]

	calc_ensemble2 <- function(..., signed = 1) {
		if (signed < 0) {
			sort(..., decreasing = TRUE, na.last = FALSE)[ranks_rev]
		} else {
			sort(..., decreasing = FALSE, na.last = TRUE)[ranks]
		}
	}

	calc_ensemble3 <- function(x, signed = 1) {
		quantile(x, probs = if (signed < 0) c(1, 0.5, 0) else c(0, 0.5, 1), type = 1, na.rm = TRUE, names = FALSE)
	}

	# Fake data
	x16 <- 1:16	# all 16 GCMs are in study area
	x8min <- c(1:8, rep(NA, 8))	# only 8 GCMs are in study area, the ones with the lowest values
	x8s <- c(2, 4, 5, 6, 7, 8, 11, 12, rep(NA, 8))	# only 8 GCMs are in study area, the ones with some but not all of the lowest values
	x2max <- c(rep(NA, 14), 15:16)	# only 2 GCMs are in study area, the ones with the highest values
	
	# Results
	sapply(list(x16, x8min, x8s, x2max), function(x) calc_ensemble1(x, signed = -1)) 
#   [,1] [,2] [,3] [,4]
#[1,]  16  8  12  16
#[2,]  9  1  2  NA
#[3,]  1  NA  NA  NA
	sapply(list(x16, x8min, x8s, x2max), function(x) calc_ensemble1(x, signed = +1)) 
#   [,1] [,2] [,3] [,4]
#[1,]  1  1  2  15
#[2,]  8  8  12  NA
#[3,]  16  NA  NA  NA

	sapply(list(x16, x8min, x8s, x2max), function(x) calc_ensemble2(x, signed = -1)) 
#  [,1] [,2] [,3] [,4]
#[1,]  16  NA  NA  NA
#[2,]  8  8  12  NA
#[3,]  1  1  2  15
	sapply(list(x16, x8min, x8s, x2max), function(x) calc_ensemble2(x, signed = +1)) 
#   [,1] [,2] [,3] [,4]
#[1,]  1  1  2  15
#[2,]  8  8  12  NA
#[3,]  16  NA  NA  NA

	sapply(list(x16, x8min, x8s, x2max), function(x) calc_ensemble3(x, signed = -1)) 
#   [,1] [,2] [,3] [,4]
#[1,]  16  8  12  16
#[2,]  8  4  6  15
#[3,]  1  1  2  15
	sapply(list(x16, x8min, x8s, x2max), function(x) calc_ensemble3(x, signed = +1)) 
#   [,1] [,2] [,3] [,4]
#[1,]  1  1  2  15
#[2,]  8  4  6  15
#[3,]  16  8  12  16

}

# Version 3.2
calc_ensemble3 <- function(..., signed = 1) {
	if (signed < 0) {
		sort(..., decreasing = TRUE, na.last = FALSE)[ranks_rev]
	} else {
		sort(..., decreasing = FALSE, na.last = TRUE)[ranks]
	}
}

# Version 4
calc_ensemble4 <- function(x, signed = 1) {
	quantile(x, probs = if (signed < 0) c(1, 0.5, 0) else c(0, 0.5, 1), type = 1, na.rm = TRUE, names = FALSE)
}




# Converts all 0s in x to NAs, e.g., useful for plotting maps
ZeroToNA <- function(x, epsilon = sqrt(.Machine$double.eps)) {
	x[abs(x) < epsilon] <- NA
	
	x
}

clean_name <- function(x, replace = list(c("/", "div"), c(".", "_")), fixed = TRUE) {
	if (length(replace) > 0) {
		x <- gsub(replace[[1]][1], replace[[1]][2], x, fixed = fixed)
		replace <- replace[-1]
		x <- Recall(x = x, replace = replace, fixed = fixed)
	}
	
	x
}

# Finds the most common element of x
majority <- function(x, na.rm = FALSE) {
	ina <- is.na(x)
	if (sum(ina) >= length(x)) {
		res <- NA
	} else {
		useMode <- FALSE
		naVal <- NULL
		if (na.rm) {
			x <- na.exclude(x)
			useMode <- TRUE
		}
		if (!na.rm && sum(ina) > 0 && !inherits(x, "integer")) {
			naVal <- min(x, na.rm = TRUE) - 100
			x[ina] <- naVal
			useMode <- TRUE
		}
		if (useMode) {
			stopifnot(requireNamespace("modeest"))
			res <- modeest::mfv(x)
		} else {
			temp <- table(x, useNA = if (na.rm) "no" else "always")
			res <- as.numeric(names(temp)[which(c(temp) == max(c(temp)))])
		}
		
		if (length(res) > 1) res <- res[sample(x = length(res), size = 1)]
		if (useMode && !is.finite(res) && res == naVal) res <- NA
	}

	res
}


#-------------------------------
#-Handling/creating GIS data

# Converts locations given by coordinates and values to a SpatialPointsDataFrame with coordinate system of mask
calc.SpatialPointsFromData <- function(Xcoord, Ycoord, dataVector, mask) {
	stopifnot(identical(length(Xcoord), length(Ycoord), length(dataVector)))
#	stopifnot(sum(is.na(dataVector)) == 0) #final project
#	mini project:
		inna <- !is.na(dataVector)
		Xcoord <- Xcoord[inna]
		Ycoord <- Ycoord[inna]
		dataVector <- dataVector[inna]
#	end mini project
	
	SpatialPointsDataFrame(coords = coordinates(data.frame(Xcoord, Ycoord)), data = data.frame(dat = dataVector), proj4string = CRS(projection(mask)))
}

# Returns a raster, made from mask, filled with values at locations given by coordinates
if (do_spatialinterpolation) {
	calc.RasterFromData <- function(Xcoord, Ycoord, dataVector, mask) {
		# inverse distance weighted (IDW) interpolation with inverse distance power set to .5
		stopifnot(identical(length(Xcoord), length(Ycoord), length(dataVector)))
	#	stopifnot(sum(is.na(dataVector)) == 0) #final project
	#	mini project:
			inna <- !is.na(dataVector)
			Xcoord <- Xcoord[inna]
			Ycoord <- Ycoord[inna]
			dataVector <- dataVector[inna]
	#	end mini project
		df <- data.frame(x = Xcoord, y = Ycoord, dat = dataVector)
		mg <- gstat(id = "dat", formula = dat ~ 1,
					locations = ~x+y, data = df,
					nmax = min(7, round(0.05 * length(dataVector))), set = list(idp = .5))
		temp <- interpolate(mask, mg, debug.level = 0)
		names(temp) <- "dat"
		
		mask(temp, mask)
	}
} else {

	calc.RasterFromData <- function(Xcoord, Ycoord, dataVector, mask) {#about 9-10x faster than v1
		r <- raster(mask)
		r[cellFromXY(r, data.frame(Xcoord, Ycoord))] <- dataVector
		
		r
	}
}

# Kendall's tau rank correlation coefficient
calc_fast_tau <- function(x, y) { 
	stopifnot(length(x) == length(y), requireNamespace(pcaPP))
	xy <- c(x, y)
	dim(xy) <- c(length(x), 2)
	xy <- xy[complete.cases(xy),]
	
	pcaPP::cor.fk(x = xy[, 1], y = xy[, 2])
}

capwords <- function(s, strict = FALSE) {# ?tolower
  cap <- function(s) paste(toupper(substring(s, 1, 1)),
         {s <- substring(s, 2); if (strict) tolower(s) else s},
               sep = "", collapse = " " )
  sapply(strsplit(s, split = " "), cap, USE.NAMES = !is.null(names(s)))
}



# Splits a global raster into regional rasters
regionalize <- function(gmask, grmasks, rmasks, write = FALSE, dir.out = NULL, name_tag = NULL, ...) {
	frmask <- list()
	for (ir in regions_N) {
		if (!is.null(rmasks[[ir]])) {
			frmask[[ir]] <- mask(crop(mask(gmask, grmasks[[ir]]), rmasks[[ir]]), rmasks[[ir]])
			if (write) {
				add_args <- list(...)
				if (!("datatype" %in% names(add_args))) datatype <- "INT1S"
				if (!("NAflag" %in% names(add_args))) NAflag <- -9
				if (!("overwrite" %in% names(add_args))) overwrite <- TRUE
				writeRaster(frmask[[ir]], file = file.path(dir.out, paste0(names(grmasks)[ir], name_tag, ".asc")), datatype = datatype, NAflag = NAflag, overwrite = overwrite, ...)
			}
		}
	}
	
	frmask
}

# Loads a masking raster with the 'pattern' area for each region at a global extent into a list
load_regional_masks <- function(dir.gis, pattern = "Global", rcp = NULL, CRS. = WGS84, regions_N. = regions_N) {
	res <- list()
	ftemp <- list.files(dir.gis, pattern = pattern)
	if (!is.null(rcp)) ftemp <- ftemp[grepl(rcp, ftemp)]
	rnames <- NULL
	for (i in regions_N.) {
		iw <- grep(paste0(pattern, i), ftemp)
		if (length(iw) == 1) {
			res[[i]] <- setMinMax(raster(x = file.path(dir.gis, ftemp[iw])))
			projection(res[[i]]) <- CRS.
		}
		rnames <- c(rnames, paste0("Region", i))
	}
	names(res) <- rnames
	
	res
}


#-------------------------------
#-Plot figures and maps
get_map_colors_old <- function(val_type, dat_cur = NULL) {
	cols1_pos <- c("burlywood4", "chocolate3", "darkgoldenrod1")
	cols1_neg <- c("darkseagreen3", "royalblue2", "mediumpurple2")
	cols_ens <- c("aquamarine3", "orange", "deeppink", "dodgerblue", "chartreuse4")
	col_boundary <- c("red", "gray20", "blue")
	cols2_pos <- c("mediumorchid", "peru", "coral", "gold", "palegoldenrod", "tomato", "red", "purple4")
	cols2_neg <- c("mediumpurple3", "steelblue", "skyblue", "darkseagreen3", "chartreuse3")
	cols_ens <- list("red", "gray", "blue")
	cols_cur <- if (!is.null(dat_cur)) { if (sd(dat_cur, na.rm = TRUE) > 0) unlist(cols_ens) else "darkgreen" } else NULL
	cols_ens_pos <- if (identical(val_type, "Mean")) list(cols1_pos, cols1_pos, cols1_pos) else list(cols2_pos, cols2_pos, cols2_pos)
	cols_ens_neg <- if (identical(val_type, "Mean")) list(cols1_neg, cols1_neg, cols1_neg) else list(cols2_neg, cols2_neg, cols2_neg)
	col_extreme_below <- "cyan"
	col_extreme_above <- "magenta"
	col_zero <- "gray"
	col_sim <- "white"
	
	list(cols1_pos = cols1_pos, cols1_neg = cols1_neg, cols_ens = cols_ens, col_boundary = col_boundary,
		cols2_pos = cols2_pos, cols2_neg = cols2_neg, cols_cur = cols_cur,
		cols_ens = cols_ens, cols_ens_pos = cols_ens_pos, cols_ens_neg = cols_ens_neg,
		col_extreme_below = col_extreme_below, col_extreme_above = col_extreme_above,
		col_zero = col_zero, col_sim = col_sim)
}

get_map_colors <- function(var_type = c("continuous", "categorical"), color_gradient = c("blue_orange", "green_orange"), extreme_type = c("contrast", "continuous")) {
	var_type <- match.arg(var_type)
	color_gradient <- match.arg(color_gradient)
	extreme_type <- match.arg(extreme_type)
	
	if (var_type == "categorical") {
		cols <- list(cur = "darkgreen", ranks = rep(list(c(adjustcolor(cols_shifts[1], alpha.f = 0.5),
														adjustcolor(cols_shifts[2], alpha.f = 0.8),
														adjustcolor(cols_shifts[3], alpha.f = 0.5))), times = length(ranks)))
	} else if (var_type == "continuous") {
		zero <- adjustcolor("darkgray", alpha.f = 0.9)
		green_gradient <- adjustalpha(colors = colorRampPalette(c("darkseagreen4", "darkolivegreen4", "darkgreen"), alpha = TRUE)(255), alphas = seq(0.1, 1, length.out = 255))
		
		if (color_gradient == "green_orange") {
			cols <- list(cur = list(pos = green_gradient[128:255],
							neg = rev(green_gradient[1:127]),
							nozero = green_gradient,
							zero = zero),
						fut = list(pos = c(adjustcolor("darkolivegreen1", alpha.f = 0.2), adjustcolor("darkolivegreen3", alpha.f = 0.7), adjustcolor("darkgreen", alpha.f = 0.7), adjustcolor("darkgreen", alpha.f = 0.9), adjustcolor("darkslategray", alpha.f = 0.9)),
							neg = c(adjustcolor("darkgoldenrod2", alpha.f = 0.2), adjustcolor("orange", alpha.f = 0.7), adjustcolor("orange2", alpha.f = 0.7), adjustcolor("chocolate", alpha.f = 0.7), adjustcolor("chocolate", alpha.f = 0.9)),
							nozero = c(adjustcolor("chocolate", alpha.f = 0.9), adjustcolor("orange", alpha.f = 0.7), adjustcolor("darkolivegreen3", alpha.f = 0.7), adjustcolor("darkgreen", alpha.f = 0.9)),
							zero = zero)
						)
		}
		if (color_gradient == "blue_orange") {
			cols <- list(cur = list(pos = green_gradient[128:255],
							neg = rev(green_gradient[1:127]),
							nozero = green_gradient,
							zero = zero),
						fut = list(pos = c(adjustcolor("lightskyblue", alpha.f = 0.2), adjustcolor("cornflowerblue", alpha.f = 0.7), adjustcolor("mediumblue", alpha.f = 0.7), adjustcolor("mediumblue", alpha.f = 0.9), adjustcolor("navy", alpha.f = 0.9)),
							neg = c(adjustcolor("darkgoldenrod2", alpha.f = 0.2), adjustcolor("orange", alpha.f = 0.7), adjustcolor("orange2", alpha.f = 0.7), adjustcolor("chocolate", alpha.f = 0.7), adjustcolor("chocolate", alpha.f = 0.9)),
							nozero = c(adjustcolor("chocolate", alpha.f = 0.9), adjustcolor("orange", alpha.f = 0.7), adjustcolor("cornflowerblue", alpha.f = 0.7), adjustcolor("navy", alpha.f = 0.9)),
							zero = zero)
						)
		}
	}
	
	if (extreme_type == "contrast") {
		col_extreme_below <- "cyan"
		col_extreme_above <- "magenta"
	} else if (extreme_type == "continous") {
		col_extreme_below <- "cyan"
		col_extreme_above <- "magenta"
	} else {
		col_extreme_below <- col_extreme_above <- "black"
	}
	
	col_sim <- "white"
	
	list(cols = cols,
		extreme_above = col_extreme_above,
		extreme_below = col_extreme_below,
		sim = col_sim)
}


# Calculate zlims and zextremes
calc_response_limits <- function(dat_cur, dat, get_ircps = NULL, get_ranks = NULL, Any17Cond = FALSE, type, probs = c(0.005, 0.995)) {
	usedRCPs <- reqRCPs
	if (!is.null(get_ircps) && get_ircps %in% seq_along(reqRCPs)) usedRCPs <- usedRCPs[get_ircps]
	usedRanks <- ranks
	if (!is.null(get_ranks) && get_ranks %in% seq_along(ranks)) usedRanks <- usedRanks[get_ranks]
	
	temp_dat <- dat["MetDef_ThisCond", usedRCPs, as.character(usedRanks), ]
	
	# Range limits for current and ranks: maximal 99% data range per 'world' slice, i.e., in no world map there are more than 1% of cells in the 'extreme' categories
	temp_cur <- quantile(if (!is.null(dat_cur)) dat_cur else temp_dat, probs = probs, na.rm = TRUE)
	
	temp2 <- temp3 <- matrix(NA, nrow = length(usedRCPs) * length(usedRanks), ncol = 2)
	for (ircp in seq_along(usedRCPs)) {
		for (ir in seq_along(usedRanks)) {
			temp2[(ircp - 1) * length(usedRanks) + ir, ] <- quantile(na.omit(as.vector(dat["MetDef_ThisCond", usedRCPs[ircp], as.character(usedRanks)[ir], ])), probs = probs, na.rm = TRUE)
			if (Any17Cond) temp3[(ircp - 1) * length(usedRanks) + ir, ] <- quantile(na.omit(as.vector(dat["MetDef_Any17Cond", usedRCPs[ircp], as.character(usedRanks)[ir], ])), probs = probs, na.rm = TRUE)
		}
	}
	if (identical(type, "Mean")) {
		temp_cur <- temp_ens <- range(temp_cur, temp2, temp3, na.rm = TRUE)
	} else {
		temp_ens <- range(temp2, temp3, na.rm = TRUE)
	}
	zlims <- c(list(temp_cur), rep(list(temp_ens), length(ranks))) # Current and one element per rank
	zlims <- lapply(zlims, function(x) if (is.finite(x) && any(abs(x) < .Machine$integer.max)) x else NA)
	
	# Range limits: all data
	temp_cur <- range(if (!is.null(dat_cur)) dat_cur else temp_dat, na.rm = TRUE)
	temp_ens <- range(temp_dat, na.rm = TRUE)
	if (Any17Cond) temp_ens <- range(temp_ens, dat["MetDef_Any17Cond", usedRCPs, as.character(usedRanks), ], na.rm = TRUE)
	if (identical(type, "Mean")) temp_cur <- temp_ens <- range(temp_cur, temp_ens, na.rm = TRUE)
	zextremes <- c(list(temp_cur), rep(list(temp_ens), length(ranks))) # Current and one element per rank
	zextremes <- lapply(zextremes, function(x) if (is.finite(x) && any(abs(x) < .Machine$integer.max)) x else NA)

	list(zlims = zlims, zextremes = zextremes)
}

prepare_range_limits <- function(zlims, zextremes, grid_cur, grid_ens) {
	if (is.null(zlims)) {
		zlims <- vector("list", 4)
		zlims[[1]] <- range(sapply(grid_cur, function(x) if (is.null(x)) NA else c(minValue(x), maxValue(x))), na.rm = TRUE)
		zlims[[2]] <- range(sapply(grid_ens, function(x) if (is.null(x)) NA else c(minValue(x), maxValue(x))), na.rm = TRUE)
		zlims[[3]] <- zlims[[4]] <- zlims[[2]]
	}
	zlims <- lapply(zlims, function(x) if (is.finite(x) && any(abs(x) < .Machine$integer.max)) x else NA)
	if (is.null(zextremes))
		zextremes <- zlims
		
	list(zlims = zlims, zextremes = zextremes)
}


#' Create and plot a continuous color legend
#'
#' @param zlim A numeric vector of length two. The smallest and largest z-value of \code{grid} for which a complete color gradient and legend should be printed.
#' @param zextreme A numeric vector length two. The minimum and maximum z-value of \code{grid}. If \code{zextreme[1] < zlim[1] || zextreme[2] > zlim[2]}, then the values in the ranges between each zextreme and zlim will be highlighted as extreme areas in a different color.
#' @param col_desc A list with the color names. A returned object from a call to the function \code{\link{make_colors}}.
#' @param grid A RasterLayer object for which the legend is created.
#' @param box A numeric vector of length four. The SW (lower left) and NE (upper right) corners of the color legend on the plotted \code{grid}.
#' @param whitebox A logical value. If \code{TRUE}, then the area of the color legend is printed white before the colors of the legend are added.
#' @param horiz A logical value. If \code{TRUE}, then the values of the color legend are printed below the legend box; if \code{FALSE}, then the values are printed on the right side of the box.
#' @param signed A numeric value. A scaling value multiplied with the z-values for determining legend values.
#' @param fun_inv_ens A function or \code{NULL}. If a function, then it will be applied to z-values for determining legend values.
#' @param srt A numerical value. String rotation in degrees, see \code{\link[graphics]{text}}.
#' @param cex A numerical value. Numeric character expansion factor, see \code{\link[graphics]{text}}.
add_legend <- function(zlim, zextreme, col_desc, grid, box = c(-100, -97, -50, -10), whitebox = TRUE, horiz = FALSE, signed = 1, fun_inv_ens = NULL, srt = 90, cex = 1) {
	if (is.null(fun_inv_ens)) fun_inv_ens <- function(x) x

	# Color ramp
	zr <- raster(xmn = box[1], xmx = box[2], ymn = box[3], ymx = box[4], crs = projection(grid), resolution = res(grid), vals = NULL)
	zr[] <- if (horiz) rep(1:dim(zr)[2], times = dim(zr)[1]) else rep(dim(zr)[1]:1, each = dim(zr)[2])
	if (whitebox) raster::image(zr, col = "white", add = TRUE)
	raster::image(zr, col = col_desc$colors_label, add = TRUE)

	# Labels	
	atz <- pretty(zlim, n = 6) #generate default labels	
	if ((temp1z <- sum(temp2z <- atz <= zlim[1])) > 0) {#adjust lowest label to limit value
		atz[tail(which(temp2z), n = 1)] <- zlim[1]
		if (temp1z > 1) atz <- atz[-head(which(temp2z), n = -1)]
	}
	if ((temp1z <- sum(temp2z <- atz >= zlim[2])) > 0) {#adjust highest label to limit value
		atz[head(which(temp2z), n = 1)] <- zlim[2]
		if (temp1z > 1) atz <- atz[-tail(which(temp2z), n = -1)]
	}
	datz <- diff(atz)
	temp <- 0.8 / (if (abs(srt) > 45) cex else 1)
	if (length(datz) > 0 && length(temp <- which(datz < temp * max(datz))) > 0) {#remove labels if too close together, but not limits and not 0
		id_remove <- findInterval(x = 1+temp, vec = 1:length(atz), all.inside = TRUE)
		if (length(temp <- which(0 == atz[id_remove])) > 0) id_remove <- id_remove[-temp]
		if (length(id_remove) > 0) atz <- atz[-id_remove]
	}
	if (length(datz) == 0) atz <- zextreme
	ltxt <- prettyNum(signif (signed * fun_inv_ens(atz), 2))
	ltext_extreme <- prettyNum(signif (signed * fun_inv_ens(zextreme), 2))
	
	# Tick position
	ext <- extent(zr)
	if (horiz) {
		xmin_orig <- ext@xmin
		if (col_desc$added_below) xmin_orig <- xmin_orig + col_desc$ncol_label_added / length(col_desc$colors_label) * (ext@xmax - ext@xmin)
		xmax_orig <- ext@xmax
		if (col_desc$added_above) xmax_orig <- xmax_orig - col_desc$ncol_label_added / length(col_desc$colors_label) * (ext@xmax - ext@xmin)
		xs_orig <- (temp <- atz / (max(atz) - min(atz)) * (xmax_orig - xmin_orig)) + (xmin_orig - min(temp))
	} else {
		ymin_orig <- ext@ymin
		if (col_desc$added_below) ymin_orig <- ymin_orig + col_desc$ncol_label_added / length(col_desc$colors_label) * (ext@ymax - ext@ymin)
		ymax_orig <- ext@ymax
		if (col_desc$added_above) ymax_orig <- ymax_orig - col_desc$ncol_label_added / length(col_desc$colors_label) * (ext@ymax - ext@ymin)
		ys_orig <- (temp <- atz / (max(atz) - min(atz)) * (ymax_orig - ymin_orig)) + (ymin_orig - min(temp))
	}
	
	# Draw ticks
	lwd_seg <- max(0.5, min(1, cex)) * par("lwd")
	if (horiz) {
		segments(x0 = xs_orig, x1 = xs_orig, y0 = ext@ymax - (ext@ymax - ext@ymin) / 3, y1 = ext@ymax, lwd = lwd_seg)
		if (col_desc$added_below) segments(x0 = ext@xmin, x1 = ext@xmin, y0 = ext@ymin, y1 = ext@ymax, lwd = lwd_seg)
		if (col_desc$added_above) segments(x0 = ext@xmax, x1 = ext@xmax, y0 = ext@ymin, y1 = ext@ymax, lwd = lwd_seg)
	} else {
		segments(x0 = ext@xmax - (ext@xmax - ext@xmin) / 3, x1 = ext@xmax, y0 = ys_orig, y1 = ys_orig, lwd = lwd_seg)
		if (col_desc$added_below) segments(x0 = ext@xmin, x1 = ext@xmax, y0 = ext@ymin, y1 = ext@ymin, lwd = lwd_seg)
		if (col_desc$added_above) segments(x0 = ext@xmin, x1 = ext@xmax, y0 = ext@ymax, y1 = ext@ymax, lwd = lwd_seg)
	}
	
	# Write tick labels
	if (horiz) {
		if (abs(srt) > 45) {
			adj <- c(0.5, 1.3)
			ly <- ext@ymax
		} else {
			adj <- c(0.5, NA)
			ly <- ext@ymax + strheight(ltxt, units = "user", cex = cex * 1.05)
		}
		text(x = xs_orig, y = ly, labels = ltxt, srt = srt, adj = adj, cex = cex, xpd = TRUE)
		if (col_desc$added_below) text(x = ext@xmin, y = ext@ymax, labels = ltext_extreme[1], srt = 90, adj = c(1.3, 1), cex = cex, xpd = TRUE)
		if (col_desc$added_above) text(x = ext@xmax, y = ext@ymax, labels = ltext_extreme[2], srt = 90, adj = c(-0.5, 1), cex = cex, xpd = TRUE)
	} else {
		if (abs(srt) > 45) {
			adj <- c(0.5, 1.3)
			lx <- ext@xmax
		} else {
			adj <- c(1, NA)
			lx <- ext@xmax + (if (ext@xmax > 0) -1 else +1) * max(strwidth(ltxt, units = "user", cex = cex * if (cex < 0.5) 1.5 else 1.05))
		}
		text(x = lx, y = ys_orig, labels = ltxt, srt = srt, adj = adj, cex = cex, xpd = TRUE)
		if (col_desc$added_below) text(x = ext@xmax, y = ext@ymin, labels = ltext_extreme[1], srt = 0, adj = c(1, 1.3), cex = cex, xpd = TRUE)
		if (col_desc$added_above) text(x = ext@xmax, y = ext@ymax, labels = ltext_extreme[2], srt = 0, adj = c(1, -0.5), cex = cex, xpd = TRUE)
	}
		
	invisible(0)
}

adjustalpha <- function(colors, alphas) {
	stopifnot(length(colors) == length(alphas))
	sapply(seq_along(colors), function(ix) adjustcolor(colors[ix], alpha.f = alphas[ix]))
}

make_colors <- function(zlim, zextremes, var_sign, val_crit, colors_Pos = NULL, colors_Neg = NULL, colors_nozero = NULL, colors_zero = NULL, colors_below = NULL, colors_above = NULL, n_colors = 1023) {
	#set default missing colors
	if (is.null(colors_Neg)) colors_Neg <- c("white", "orange")
	if (is.null(colors_Pos)) colors_Pos <- c("white", "darkgreen")
	if (is.null(colors_zero)) colors_zero <- "gray"
	if (is.null(colors_nozero)) colors_nozero <- c(rev(colors_Neg), colors_Pos)

	# negative signs indicate that low values correlate with high aridity
	if (var_sign > 0) {
		temp <- colors_Neg
		colors_Neg <- colors_Pos 
		colors_Pos <- temp
		colors_nozero <- rev(colors_nozero)
		temp <- colors_below
		colors_below <- colors_above
		colors_above <- temp
	}
	
	# make color ramp
	if (zlim[1] < val_crit && zlim[2] > val_crit) { #colors cross val_crit
		n_zero1 <- round(temp <- max(1, (val_crit - zlim[1]) / (zlim[2] - zlim[1]) * n_colors))
		n_zero2 <- ceiling(temp)
		n_zero <- length(unique(c(n_zero1, n_zero2)))
		if (is.null(colors_zero)) {
			colors <- c(colorRampPalette(rev(colors_Neg), alpha = TRUE)(n_zero1 - 1 + n_zero), colorRampPalette(colors_Pos, alpha = TRUE)(n_colors - n_zero2 + n_zero - ifelse(n_zero > 1, 2, 1)))
		} else {
			colors <- c(colorRampPalette(rev(colors_Neg), alpha = TRUE)(n_zero1 - 1), rep(colors_zero, times = n_zero), colorRampPalette(colors_Pos, alpha = TRUE)(n_colors - n_zero2))
		}
	} else { #colors do not cross val_crit
		colors <- colorRampPalette(colors_nozero, alpha = TRUE)(n_colors)
	}
	# one bound is val_crit
	if (zlim[1] == val_crit) colors[1] <- colors_zero
	if (zlim[2] == val_crit) colors[n_colors] <- colors_zero
	
	#---Add extreme color above and below, and add zero color at val_crit
	added_below <- added_above <- FALSE
	ncol_label_added <- max(5, round(0.05 * n_colors))
	ncol_map_added_below <- ncol_map_added_above <- 0
	colors_map <- colors_label <- colors
	if (!is.null(colors_below) && zextremes[1] < zlim[1]) {
		added_below <- TRUE
		if (zlim[2] - zlim[1] > sqrt(.Machine$double.eps)) {
			ncol_map_added_below <- ceiling((zlim[1] - zextremes[1]) / (zlim[2] - zlim[1]) * n_colors)
		} else {
			ncol_map_added_below <- ncol_label_added
		}
		colors_map <- c(rep(colors_below, ncol_map_added_below), colors_map)
		colors_label <- c(rep(colors_below, ncol_label_added), colors_label)
	}
	if (!is.null(colors_zero) && added_below && zextremes[1] <= 0 && zlim[1] > val_crit) {
		colors_map[round(temp <- max(1, (val_crit - zextremes[1]) / (zlim[1] - zextremes[1]) * ncol_map_added_below)):ceiling(temp)] <- colors_zero
		colors_label[round(temp <- max(1, (val_crit - zextremes[1]) / (zlim[1] - zextremes[1]) * ncol_label_added)):ceiling(temp)] <- colors_zero
	}
	if (!is.null(colors_above) && zextremes[2] > zlim[2]) {
		added_above <- TRUE
		if (zlim[2] - zlim[1] > sqrt(.Machine$double.eps)) {
			ncol_map_added_above <- ceiling((zextremes[2] - zlim[2]) / (zlim[2] - zlim[1]) * n_colors)
		} else {
			ncol_map_added_above <- ncol_label_added
		}
		colors_map <- c(colors_map, rep(colors_above, ncol_map_added_above))
		colors_label <- c(colors_label, rep(colors_above, ncol_label_added))
	}
	if (!is.null(colors_zero) && added_above && zextremes[2] >= val_crit && zlim[2] < val_crit) {
		colors_map[length(colors_map) - ncol_map_added_above + floor(temp <- min(ncol_map_added_above - 1, (zextremes[2] - val_crit) / (zextremes[2] - zlim[2]) * ncol_map_added_below)):round(temp)] <- colors_zero
		colors_label[length(colors_label) - ncol_label_added + floor(temp <- min(ncol_label_added -1, (zextremes[2] - val_crit) / (zextremes[2] - zlim[2]) * ncol_label_added)):round(temp)] <- colors_zero
	}

	list(colors_map = colors_map, colors_label = colors_label, added_above = added_above, added_below = added_below, ncol_label_added = ncol_label_added)
}

set_colors <- function(legends_type, var_sign, mapcols, val_crit, zlims, zextremes) {
	# Color for simulation background
	col_sim <- mapcols$sim
	
	# Colors for current data
	if (identical(legends_type[1], "continuous")) {
		col_desc_cur <- make_colors(zlim = zlims[[1]], zextremes = zextremes[[1]], var_sign, val_crit, colors_Pos = mapcols$cols$cur$pos, colors_Neg = mapcols$cols$cur$neg, colors_nozero = mapcols$cols$cur$nozero, colors_zero = mapcols$cols$cur$zero, colors_below = mapcols$extreme_below, colors_above = mapcols$extreme_above, n_colors = 255)
		cols_cur <- col_desc_cur$colors_map
	} else {
		col_desc_cur <- list()
		cols_cur <- mapcols$cols$cur
	}
	# Colors for ensemble and ensemble-study area data
	cols_ens <- col_desc_ens <- vector("list", length(shifts))
	for (i in seq_along(shifts)) {
		if (identical(legends_type[1 + i], "continuous")) {
			col_desc_ens[[i]] <- make_colors(zlim = zlims[[1 + i]], var_sign, val_crit, zextremes = zextremes[[1 + i]], colors_Pos = mapcols$cols$fut$pos, colors_Neg = mapcols$cols$fut$neg, colors_nozero = mapcols$cols$fut$nozero, colors_zero = mapcols$cols$fut$zero, colors_below = mapcols$extreme_below, colors_above = mapcols$extreme_above, n_colors = 255)
			cols_ens[[i]] <- col_desc_ens[[i]]$colors_map
		} else {
			cols_ens[[i]] <- mapcols$cols$ranks[[i]]
		}
	}	

	list(col_sim = col_sim, col_desc_cur = col_desc_cur, cols_cur = cols_cur,
		col_desc_ens = col_desc_ens, cols_ens = cols_ens)
}



#TODO: zlim labels should not overlap
get_digits <- function(x, n_min = 1, n_max = 3) {
	x <- na.exclude(x)
	min(n_max, max(n_min, floor(1 + log(max(abs(x)), base = 10)), floor(1 + log(max(abs(1/x)), base = 10))))
}


plot_panel <- function(ircp, ir, i, zlims, zextremes, cex = 1, cex_legend = 1, srt_legend = 90,
						add_panel_letter, panel = "", panel_line = 0, add_scenario_name, add_region_name, xann, yann, add_legends,
						rmasks_sim, grid_cur, grid_Any17Cond, grid_ens,
						boundary_shifts_ensemble, rmasks_sim_poly,
						legends, legends_type, legends_text, legend_sim, legend_box = c(-100, -97, -50, -10),
						cols, 
						fun_inv_ens = NULL, shifts_code. = rep(1, length(shifts))) {

	# Set up 'empty' or 'simulation extent' background panel
	image(rmasks_sim[[i]], maxpixels = ncell(rmasks_sim[[i]]), cex = cex, col = cols$col_sim, asp = 1, xlab = "", ylab = "", axes = FALSE, add = FALSE)

	# Decorate plot
	if (add_scenario_name) {
		temp <- if (ircp == 0) currentSc else paste0(reqRCPs[ircp], ", rank ", ranks[ir])
		mtext(side = 3, text = temp, line = 0.6, font = 2, cex = par("cex") * cex)
	}
	if (add_region_name) mtext(side = 3, text = label.regions[i], line = -1, cex = par("cex") * cex)
	if (xann) axis(side = 1, cex = cex)
	if (yann) axis(side = 2, cex = cex)
	if (add_panel_letter) {
		if (fig_style == "nature") {
			mtext(side = 3, line = panel_line, adj = 0.05, cex = par("cex") * cex, font = 2, text = tolower(panel))
		} else {
			mtext(side = 3, line = panel_line, adj = 0.05, cex = par("cex") * cex, text = paste0("(", panel, ")"))
		}
	} 
	
	# Add current data to panel
	if (ircp == 0)
		image(grid_cur[[i]], maxpixels = ncell(grid_cur[[i]]), col = cols$cols_cur, zlim = zextremes[[1]], add = TRUE)

	# Add ensemble background study-area data to panel
	if (ircp > 0 && !is.null(grid_Any17Cond)) {
		if (!is.null(grid_Any17Cond[[i]])) {
			temp_col <- if (legends_type[1 + ir] == "categorical") cols$cols_ens[[ir]] else cols$cols_ens[[ir]]
			image(grid_Any17Cond[[i]], maxpixels = ncell(grid_Any17Cond[[i]]), col = temp_col, zlim = zextremes[[1 + ir]], add = TRUE)
		}
	}

	# Add ensemble data to panel
	if (ircp > 0) for (iss in seq_along(shifts)) {
		if (!is.null(grid_ens[[iss]][[i]])) {
			temp_col <- if (legends_type[1 + ir] == "categorical") cols$cols_ens[[ir]][iss] else cols$cols_ens[[iss]]
			image(grid_ens[[iss]][[i]], maxpixels = ncell(grid_ens[[iss]][[i]]), col = temp_col, zlim = zextremes[[1 + iss]], add = TRUE)				
		}
	}
						
	# Add country (and US state) boundaries to panel
	ext <- par()$usr
	map("world", xlim = ext[1:2], ylim = ext[3:4], lwd = 0.5, col = "gray30", resolution = 0, add = TRUE)
	if (i == 6) map("state", xlim = ext[1:2], ylim = ext[3:4], lwd = 0.5, col = "gray30", resolution = 0, add = TRUE)

	# Add shift boundaries to panel
	if (ircp > 0 && !is.null(boundary_shifts_ensemble)) for (iss in seq_along(shifts)) {
		temp_boundary <- boundary_shifts_ensemble[ircp, ir, shifts[iss]][[1]]
		if (!is.null(temp_boundary)) {
			temp_boundary <- spTransform(temp_boundary, CRS = CRS("+init = epsg:3395")) #WGS 84 / World Mercator 
			if (identical(shifts[iss], "stable")) {
				temp_boundary <- gBuffer(temp_boundary, width = -3000, capStyle = "SQUARE", joinStyle = "MITRE", mitreLimit = 3)
			} else {
				temp_boundary <- gBuffer(temp_boundary, width = +3000, capStyle = "SQUARE", joinStyle = "MITRE", mitreLimit = 3)
			}
			temp_boundary <- spTransform(temp_boundary, CRS = WGS84)
			temp_boundary <- gIntersection(temp_boundary, rmasks_sim_poly[[i]])
			if (!is.null(temp_boundary)) plot(temp_boundary, border = cols$col_boundary[iss], lwd = 0.5, add = TRUE)
		}
	}
	
	# Add legends to panel
	if (add_legends[1]) {
		if (identical(legends_type[1], "categorical")) {
			legend(x = "bottomleft", bty = "n", legend = legends_text[[1]], pch = 15, col = adjustcolor(c(if (legend_sim) cols$col_sim, cols_cur), alpha.f = 100), cex = 1.5 * cex_legend)
		} else {
			add_legend(zlim = zlims[[1]], zextreme = zextremes[[1]], col_desc = cols$col_desc_cur, grid = grid_cur[[i]], box = legend_box, signed = 1, fun_inv_ens = NULL, srt = srt_legend, cex = cex_legend)
		}
	}
	if (add_legends[2]) {#Note: 3 legends for each shift, but we spread them across the panels for ranks 1-3 (hence, we index here with ir instead of iss)
		if (identical(legends_type[1 + ir], "categorical")) {
			if (ir == 1 && all(!legends[3:4])) { #only one ensemble legend requested -> collapse labels for the shifts into the first legend
				legend(x = "bottomleft", bty = "n", legend = legends_text[[1 + ir]], pch = 15, col = adjustcolor(unlist(cols$cols_ens), alpha.f = 100), cex = 1.5 * cex_legend)
			} else {
				legend(x = "bottomleft", bty = "n", legend = legends_text[[1 + ir]], pch = 15, col = adjustcolor(cols$cols_ens[[ir]], alpha.f = 100), cex = 1.5 * cex_legend)
			}
		} else { #continuous
			add_legend(zlim = zlims[[1 + ir]], zextreme = zextremes[[1 + ir]], col_desc = cols$col_desc_ens[[ir]], grid = grid_cur[[i]], box = legend_box, signed = shifts_code.[ir], fun_inv_ens = fun_inv_ens, srt = srt_legend, cex = cex_legend)
		}
	}
	
	invisible(NULL)
}



plot_response_regional_grids_horiz <- function(mask_global, mask_regions, mask_gregions, #default: ircp = 2, RCP85; ir = 2, rank8
								dat_cur, dat_shifts = NULL, dat_Any17Cond = NULL,
								var_sign = -1, zlims, zextremes,
								val_crit = 0,
								cex = 1,
								legends = c(TRUE, TRUE, FALSE, FALSE),
								legends_type = rep("categorical", 4), # "categorical" or "continuous"
								legends_text = list("Study area", shifts, shifts, shifts),
								mapcols,
								dir.out, fname) {
	
	#---Set colors
	cols <- set_colors(legends_type, var_sign, mapcols, val_crit, zlims, zextremes)
	
	#---Get background raster
	grid_cur <- calc.RasterFromData(Xcoord = dLoc$X_WGS84, Ycoord = dLoc$Y_WGS84, dataVector = dat_cur, mask = mask_global)
	grid_cur_regions <- regionalize(grid_cur, mask_gregions, mask_regions, write = FALSE)

	#---Plot pdf
	h.panel <- 2.5; w.panel <- 3; w.edge <- 0.4; h.edgeL <- 0.25; h.edgeU <- 0.3
	pdf(height = h.edgeL + h.panel * length(regions_n) + h.edgeU, width = w.edge + w.panel * (1 + length(reqRCPs) * length(ranks)), file = file.path(dir.out, fname))
	layout(matrix(c(rep(0, 1 + length(regions_n) + 1), sapply(1:(1 + length(reqRCPs) * length(ranks)), function(x) c(0, (x - 1)*length(regions_n) + 1:length(regions_n), 0))), nrow = 1 + length(regions_n) + 1, ncol = 1 + 1 + length(reqRCPs) * length(ranks), byrow = FALSE), heights = c(h.edgeU, rep(h.panel, times = length(regions_n)), h.edgeL), widths = c(w.edge, rep(w.panel, times = 1 + length(reqRCPs) * length(ranks))))
	op <- par(mgp = c(1, 0, 0), mar = c(0.5, 0.5, 0.5, 0.2), tcl = 0.3, cex = cex)
	
	i_panel <- 1
	for (ircp in c(0, seq_along(reqRCPs))) {
		if (ircp == 0) {# Current panels
			n_ranks <- 1
		} else { # Ensemble x ranks panels
			n_ranks <- seq_along(ranks)
		}
		for (ir in n_ranks) {
			if (ircp == 0) {
				grid_regions <- lapply(list(grid_cur), function(x) regionalize(x, mask_gregions, mask_regions, write = FALSE))
				grid_Any17Cond_regions <- NULL
			} else {
				if (!is.null(dat_shifts)) {
					grid_rank <- lapply(shifts, function(ish) calc.RasterFromData(Xcoord = dLoc$X_WGS84, Ycoord = dLoc$Y_WGS84, dataVector = dat_shifts[ish, ircp, ir, ], mask = mask_global))
					grid_regions <- lapply(grid_rank, function(x) regionalize(x, mask_gregions, mask_regions, write = FALSE))
				} else {
					grid_regions <- NULL
				}
				if (!is.null(dat_Any17Cond)) {
					grid_Any17Cond <- calc.RasterFromData(Xcoord = dLoc$X_WGS84, Ycoord = dLoc$Y_WGS84, dataVector = dat_Any17Cond[ircp, ir, ], mask = mask_global)
					grid_Any17Cond_regions <- regionalize(grid_Any17Cond, mask_gregions, mask_regions, write = FALSE)
				} else {
					grid_Any17Cond_regions <- NULL
				}
			}
			
			for (i in regions_n) {
				# Determine if there is something to be plotted
				if (ircp > 0) {
					do_plot_panel <- !is.null(grid_regions[[1]][[ir]]) && (ncell(grid_regions[[1]][[ir]]) - cellStats(grid_regions[[1]][[ir]], "countNA") > 0) ||
										!is.null(grid_Any17Cond_regions[[ir]]) && (ncell(grid_Any17Cond_regions[[ir]]) - cellStats(grid_Any17Cond_regions[[ir]], "countNA") > 0)
				} else {
					do_plot_panel <- TRUE
				}
		
				if (do_plot_panel) {
					plot_panel(ircp, ir, i, zlims, zextremes,
								cex, cex_legend = 0.75 * cex, srt_legend = 0, 
								add_panel_letter = FALSE, panel = letters[i_panel + 1], panel_line = 0, 
								add_scenario_name = (i == regions_n[1]), add_region_name = (ircp == 0), xann = TRUE, yann = (ircp == 0),
								add_legends = c(legends[1] && ircp == 0 && i == regions_n[1], legends[1 + ir] && ircp == 1 && ir <= 3 && i == regions_n[1]),
								rmasks_sim = mask_regions, grid_cur = grid_cur_regions, grid_Any17Cond = grid_Any17Cond_regions, grid_ens = grid_regions,
								boundary_shifts_ensemble = NULL, rmasks_sim_poly = NULL,
								legends, legends_type, legends_text, legend_sim = FALSE, legend_box = c(-90, -87, -45, -20),
								cols = cols, 
								fun_inv_ens = NULL, shifts_code. = rep(1, length(shifts)))
					if (ircp == 0) mtext(side = 2, line = 1.2, "Latitude", cex = par()$cex * cex)
					if (i == max(regions_n)) mtext(side = 1, line = 0.8, "Longitude", cex = par()$cex * cex)
					i_panel <- i_panel + 1
				} else {
					plot.new()
				}
			}

		}
	}
	
	par(op)
	dev.off()
}


plot_response_regional_grids_vertical <- function(mask_global, mask_regions, mask_gregions, #default: ircp = 2, RCP85; ir = 2, rank8
								dat_cur, dat_shifts = NULL, dat_Any17Cond = NULL,
								var_sign = -1, zlims, zextremes,
								val_crit = 0,
								cex = 1,
								legends = c(TRUE, TRUE, FALSE, FALSE),
								legends_type = rep("categorical", 4), # "categorical" or "continuous"
								legends_text = list("Study area", shifts, shifts, shifts),
								mapcols,
								dir.out, fname) {
	
	#---Set colors
	cols <- set_colors(legends_type, var_sign, mapcols, val_crit, zlims, zextremes)
	
	#---Get background raster
	grid_cur <- calc.RasterFromData(Xcoord = dLoc$X_WGS84, Ycoord = dLoc$Y_WGS84, dataVector = dat_cur, mask = mask_global)
	grid_cur_regions <- regionalize(grid_cur, mask_gregions, mask_regions, write = FALSE)

	#---Plot pdf
	h.panel <- 2.5; w.panel <- 3; w.edgeL <- 0.4; w.edgeU <- 0.1; h.edgeL <- 0.1; h.edgeU <- 0.4
	pdf(height = h.edgeL + h.panel * (1 + length(reqRCPs) * length(ranks)) + h.edgeU, width = w.edgeL + w.panel * length(regions_n)+ w.edgeU, file = file.path(dir.out, fname))
	layout(t(matrix(c(rep(0, 1 + length(regions_n) + 1), sapply(1:(1 + length(reqRCPs) * length(ranks)), function(x) c(0, (x - 1)*length(regions_n) + 1:length(regions_n), 0)), rep(0, 1 + length(regions_n) + 1)),
				nrow = 1 + length(regions_n) + 1,
				ncol = 1 + 1 + length(reqRCPs) * length(ranks) + 1,
				byrow = FALSE)),
			heights = c(w.edgeU, rep(w.panel, times = 1 + length(reqRCPs) * length(ranks)), w.edgeL),
			widths = c(h.edgeU, rep(h.panel, times = length(regions_n)), h.edgeL))
	op <- par(mgp = c(1, 0, 0), mar = c(0.5, 0.5, 0.5, 0.2), tcl = 0.3, cex = cex)
	
	i_panel <- 1
	panel_letters <- c(letters, paste0(letters[1], letters))
	
	for (ircp in c(0, seq_along(reqRCPs))) {
		if (ircp == 0) {# Current panels
			n_ranks <- 1
		} else { # Ensemble x ranks panels
			n_ranks <- seq_along(ranks)
		}
		for (ir in n_ranks) {
			if (ircp == 0) {
				grid_regions <- lapply(list(grid_cur), function(x) regionalize(x, mask_gregions, mask_regions, write = FALSE))
				grid_Any17Cond_regions <- NULL
			} else {
				if (!is.null(dat_shifts)) {
					grid_rank <- lapply(shifts, function(ish) calc.RasterFromData(Xcoord = dLoc$X_WGS84, Ycoord = dLoc$Y_WGS84, dataVector = dat_shifts[ish, ircp, ir, ], mask = mask_global))
					grid_regions <- lapply(grid_rank, function(x) regionalize(x, mask_gregions, mask_regions, write = FALSE))
				} else {
					grid_regions <- NULL
				}
				if (!is.null(dat_Any17Cond)) {
					grid_Any17Cond <- calc.RasterFromData(Xcoord = dLoc$X_WGS84, Ycoord = dLoc$Y_WGS84, dataVector = dat_Any17Cond[ircp, ir, ], mask = mask_global)
					grid_Any17Cond_regions <- regionalize(grid_Any17Cond, mask_gregions, mask_regions, write = FALSE)
				} else {
					grid_Any17Cond_regions <- NULL
				}
			}
			
			for (i in regions_n) {
				# Determine if there is something to be plotted
				if (ircp > 0) {
					do_plot_panel <- !is.null(grid_regions[[1]][[ir]]) && (ncell(grid_regions[[1]][[ir]]) - cellStats(grid_regions[[1]][[ir]], "countNA") > 0) ||
										!is.null(grid_Any17Cond_regions[[ir]]) && (ncell(grid_Any17Cond_regions[[ir]]) - cellStats(grid_Any17Cond_regions[[ir]], "countNA") > 0)
				} else {
					do_plot_panel <- TRUE
				}
		
				if (do_plot_panel) {
					plot_panel(ircp, ir, i, zlims, zextremes,
								cex, cex_legend = 0.75 * cex, srt_legend = 0, 
								add_panel_letter = TRUE, panel = panel_letters[i_panel], panel_line = 0, 
								add_scenario_name = FALSE, add_region_name = FALSE, xann = (ircp == length(reqRCPs) && ir == length(ranks)), yann = TRUE,
								add_legends = c(legends[1] && ircp == 0 && i == regions_n[1], legends[1 + ir] && ircp == 1 && ir <= 3 && i == regions_n[1]),
								rmasks_sim = mask_regions, grid_cur = grid_cur_regions, grid_Any17Cond = grid_Any17Cond_regions, grid_ens = grid_regions,
								boundary_shifts_ensemble = NULL, rmasks_sim_poly = NULL,
								legends, legends_type, legends_text, legend_sim = FALSE, legend_box = c(-90, -87, -45, -20),
								cols = cols, 
								fun_inv_ens = NULL, shifts_code. = rep(1, length(shifts)))
					if (i == regions_n[1]) mtext(side = 2, line = 1.2, paste0("Latitude (", reqRCPs_wCur[1 + ircp], if (ircp > 0) paste0(", rank", ranks[ir]) else NULL, ")"), cex = par()$cex * cex)
					if (ircp == length(reqRCPs) && ir == length(ranks)) mtext(side = 1, line = 0.8, "Longitude", cex = par()$cex * cex)
					i_panel <- i_panel + 1
				} else {
					plot.new()
				}
			}

		}
	}
	
	par(op)
	dev.off()
}




plot_mainresponse_regional_grids <- function(ircp = 2, ir = 2, mask_global, mask_regions, mask_gregions, #default: ircp = 2, RCP85; ir = 2, rank8
								dat_cur, dat_shifts = NULL, dat_Any17Cond = NULL,
								var_sign = -1, zlims, zextremes,
								val_crit = 0,
								cex = 1,
								legends = c(TRUE, TRUE, FALSE, FALSE),
								legends_type = rep("categorical", 4), # "categorical" or "continuous"
								legends_text = list("Study area", shifts, shifts, shifts),
								legend_sim = FALSE,
								mapcols,
								relArealBar = FALSE,
								dir.out, fname) {
	
	#---Set colors
	cols <- set_colors(legends_type, var_sign, mapcols, val_crit, zlims, zextremes)
	

	#---Plot pdf
	h.panel <- 2.5; w.panel <- 3; w.edge <- 0.4; h.edgeL <- 0.25
	pdf(height = h.edgeL + h.panel * 2, width = w.edge + w.panel * 3, file = file.path(dir.out, fname))
	layout(matrix(c(rep(0, 1 + 2), sapply(1:3, function(x) c((x - 1)*2 + 1:2, 0))), nrow = 1 + 2, ncol = 1 + 3, byrow = FALSE), heights = c(rep(h.panel, times = 2), h.edgeL), widths = c(w.edge, rep(w.panel, times = 3)))
	op <- par(mgp = c(1, 0, 0), mar = rep(0.75, 4), tcl = 0.3, cex = cex)

	# First panel: world map with regions
	i_panel <- 1
	image(mask_global, maxpixels = ncell(mask_global), xlim = c(-125, 130), ylim = c(-40, 50), xlab = "", ylab = "", col = "white", asp = 1, cex = cex, axes = FALSE)
	axis(1, pos = -90)
	axis(2, at = c(-90, (ats <- axTicks(2))[ats >= -90 & ats <= 90], 90))
	mtext(side = 2, line = 1.2, "Latitude", cex = par("cex") * cex)
	if (fig_style == "nature") {
		mtext(side = 3, line = -0.5, adj = 0.05, cex = cex, font = 2, text = tolower(letters[i_panel]))
	} else {
		mtext(side = 3, line = -0.5, adj = 0.05, cex = cex, text = paste0("(", letters[i_panel], ")"))
	}
	if (!is.null(dat_cur) && sum(!is.na(dat_cur)) > 0) {
		grid_cur <- calc.RasterFromData(Xcoord = dLoc$X_WGS84, Ycoord = dLoc$Y_WGS84, dataVector = dat_cur, mask = mask_global)
		raster::image(grid_cur, col = cols$cols_cur, add = TRUE)
	}
	lapply(mask_regions[regions_n], function(x) {rct <- extent(x); rect(rct@xmin, rct@ymin, rct@xmax, rct@ymax, lwd = 1, border = "black")})
	map("world", lwd = 0.5, col = "gray30", resolution = 0, add = TRUE)
	if (legends[1]) {
		if (identical(legends_type[1], "categorical")) {
			legend(x = "bottomleft", bty = "n", legend = legends_text[[1]], pch = 15, col = c(if (legend_sim) cols$col_sim, cols$cols_cur), cex = 0.3 * cex)
		} else {
			#add_legend(zlim = zlims[[1]], zextreme = zextremes[[1]], col_desc = cols$col_desc_cur, grid = grid_cur, box = c(-115, -105, -60, 10), signed = 1, fun_inv_ens = NULL, srt = 0, cex = 0.3 * cex)
			add_legend(zlim = zlims[[1]], zextreme = zextremes[[1]], col_desc = cols$col_desc_cur, grid = grid_cur, box = c(-30, 100, -80, -65), horiz = TRUE, signed = 1, fun_inv_ens = NULL, srt = 0, cex = 0.75 * cex)
		}
	}
	
	# Next panels: region map with rcp/rank response
	# prepare data
	i_panel <- 2
	if (!is.null(dat_shifts)) {
		grid_rank <- lapply(shifts, function(ish) calc.RasterFromData(Xcoord = dLoc$X_WGS84, Ycoord = dLoc$Y_WGS84, dataVector = dat_shifts[ish, ircp, ir, ], mask = mask_global))
		grid_regions <- lapply(grid_rank, function(x) regionalize(x, mask_gregions, mask_regions, write = FALSE))
	} else {
		grid_regions <- NULL
	}
	if (!is.null(dat_Any17Cond)) {
		grid_Any17Cond <- calc.RasterFromData(Xcoord = dLoc$X_WGS84, Ycoord = dLoc$Y_WGS84, dataVector = dat_Any17Cond[ircp, ir, ], mask = mask_global)
		grid_Any17Cond_regions <- regionalize(grid_Any17Cond, mask_gregions, mask_regions, write = FALSE)
	} else {
		grid_Any17Cond_regions <- NULL
	}
	# Relative areal contribution
	if (relArealBar && !is.null(dat_shifts)) {
		table_area <- read.csv(file.path(dir.gtd, "Prj03_GlobalVulnerability", "4_Analysis", "4_Analysis_v4", "6_Results", "1_StudyArea", "Tables", "Table_S4_Change of global temperate dryland area relative to current geographic extent_v2.csv"), row.names = 1)
	}
	# loop through panels and plot
	for (i in c(1, 6, 4, 5, 3)) {
		# Determine if there is something to be plotted
		if (ircp > 0) {
			do_plot_panel <- !is.null(grid_regions[[1]][[i]]) && (ncell(grid_regions[[1]][[i]]) - cellStats(grid_regions[[1]][[i]], "countNA") > 0) ||
								!is.null(grid_Any17Cond_regions[[i]]) && (ncell(grid_Any17Cond_regions[[i]]) - cellStats(grid_Any17Cond_regions[[i]], "countNA") > 0)
		} else {
			do_plot_panel <- TRUE
		}
		
		if (do_plot_panel) {
			plot_panel(ircp, ir, i, zlims, zextremes,
						cex, cex_legend = 0.75 * cex, srt_legend = 0, 
						add_panel_letter = TRUE, panel = letters[i_panel], panel_line = -0.5,
						add_scenario_name = FALSE, add_region_name = FALSE, xann = TRUE, yann = TRUE,
						add_legends = c(FALSE, i == 1 && legends[1 + i]),
						rmasks_sim = mask_regions, grid_cur, grid_Any17Cond = grid_Any17Cond_regions, grid_ens = grid_regions,
						boundary_shifts_ensemble = NULL, rmasks_sim_poly = NULL,
						legends, legends_type, legends_text = lapply(legends_text, capwords), legend_sim = FALSE, legend_box = c(-90, -87, -45, -20),
						cols, 
						fun_inv_ens = NULL, shifts_code. = rep(1, length(shifts)))
			if (i == 1) mtext(side = 2, line = 1.2, "Latitude", cex = par()$cex * cex)
			if (i %in% c(1, 3, 4)) mtext(side = 1, line = 0.8, "Longitude", cex = par()$cex * cex)
			if (relArealBar && !is.null(dat_shifts)) {
				temp <- table_area[table_area$Var2 == reqRCPs[ircp] & table_area$Var3 == paste0("rank", ranks[ir]) & table_area$Var1 %in% shifts, paste0("Region", i)] 
				temp <- c(0, temp[1], 1 - temp[1], temp[2]) #shifts
				temp <- cumsum(ifelse(is.na(temp), 0, temp))
				usr <- par("usr")
				wb <- 1.5 * strwidth("999999"); hb <- 0.5 * strheight("9")
				x0 <- usr[1] + 0.15 * (usr[2] - usr[1])
				y0 <- usr[4] - 0.0 * (usr[4] - usr[3]); y1 <- y0 - hb
				for (ish in seq_along(shifts)) {
					rect(xleft = x0 + wb * temp[ish],
						xright = x0 + wb * temp[ish + 1],
						ybottom = y0, ytop = y1,
						col = cols_shifts[ish], border = cols_shifts[ish])
					if (ish %in% c(1, 3))
						segments(x0 = x0 + wb * temp[ish], x1 = x0 + wb * temp[ish], y0 = y0, y1 = y0 - 1.25 * hb, col = "black", lend = 1)
				}
				segments(x0 = x0 + wb * temp[4], x1 = x0 + wb * temp[4], y0 = y0, y1 = y0 - 1.25 * hb, col = "black", lend = 1)
				segments(x0 = x0, x1 = x0 + wb * temp[4], y0 = y1, y1 = y1, col = "black", lend = 1)
			}
			i_panel <- i_panel + 1
		} else {
			plot.new()
		}
	}
	
	par(op)
	dev.off()
}


hist_inset <- function(dTrail, dStable, dLead, ext, cols = NULL, cols_shifts12 = NULL, cols_shift3 = NULL, ann = FALSE) {
	# Count agreement levels
	ncols <- 1 + length(reqGCMs)
	temp <- lapply(list(dTrail, dStable, dLead), function(x) table(x))
	hs <- matrix(NA, nrow = 3, ncol = ncols)
	for (ish in seq_along(shifts))
		hs[ish, 1 + as.integer(names(temp[[ish]]))] <- temp[[ish]]
	stopifnot(identical(hs[1, -c(1, ncols)], rev(hs[2, -c(1, ncols)]))) # since current == const, then trailing + stable == 16
	hs[1:2, ] <- -hs[1:2, ] # trailing and stable will be on the negative side of the histogram x-axis

	vrange <- c(min(hs[1:2, -1], na.rm = TRUE), max(hs[3, -1], na.rm = TRUE))
	vrange_min <- round(diff(vrange) / 4)	# no side should be too small
	vrange <- c(min(-vrange_min, vrange[1]), max(+vrange_min, vrange[2]))
	hrange <- 0:length(reqGCMs)
	
	
	# Colors
	if (!is.null(cols)) {
		cols_shifts12 <- colorRampPalette(c(cols[2], cols[1]))(ncols)
		cols_shift3 <- colorRampPalette(c("white", cols[3]))(ncols)
	}
	if (!(length(cols_shifts12) == ncols && length(cols_shift3 == ncols))) {
		cols_shifts12 <- colorRampPalette(cols_shifts12)(ncols)
		cols_shift3 <- colorRampPalette(cols_shift3)(ncols)
	}
	if (!(cols_shift3[1] == "white" || cols_shift3[1] == "#FFFFFF")) {
		cols_shift3[1] <- "#FFFFFF"
	}
	
	# Shift to ext
	xtrans <- c(ext[1] + abs(vrange[1]) / diff(vrange) * diff(ext[1:2]), diff(ext[1:2]) / diff(vrange))
	ytrans <- c(ext[3] + abs(hrange[1]) / ncols * diff(ext[3:4]), diff(ext[3:4]) / ncols)
	
	hstrans12 <- xtrans[1] + c(hs[2, ncol(hs)], hs[1, -1]) * xtrans[2]
	hstrans3 <- xtrans[1] + c(0, hs[3, -1]) * xtrans[2]
	hzero <- hstrans3[1]
	htrans <- c(ytrans[1] + hrange * ytrans[2], ext[4])
	
	ext <- extent(ext) * (1 + max(dev.size("cm") / dev.size("px")))	# account for line thickness of bars

	# Plot
	rect(ext[1], ext[3], ext[2], ext[4], border = "black", col = "white", lwd = 0.75)
	for (ih in seq_along(hstrans12)) {
		if (!is.na(hstrans12[ih])) rect(xleft = hstrans12[ih], ybottom = htrans[ih], xright = hzero, ytop = htrans[1 + ih], border = NA, col = cols_shifts12[ih], lwd = 0.5)
		if (!is.na(hstrans3[ih])) rect(xleft = hzero, ybottom = htrans[ih], xright = hstrans3[ih], ytop = htrans[1 + ih], border = NA, col = cols_shift3[ih], lwd = 0.5)
	}
	
	# Axes
	segments(x0 = hzero, y0 = ext[3], y1 = ext[4], col = "black", lwd = 0.75)
		
	add_ann <- function(side = c(2, 4), aty = 1, cex = 0.6, label = "") {
		if (side == 2) {
			ix <- 1
			sx <- 1
		} else {
			ix <- 2
			sx <- -1
		}
		ytemp <- mean(htrans[aty:(aty + 1)])
		segments(x0 = ext[ix], y0 = ytemp, x1 = ext[ix] + sx * 0.03 * (ext[2] - ext[1]), col = "black", lwd = 0.75)
		
		if (nchar(label) > 0)
			text(x = ext[ix] - sx * 1.25 * cex * strwidth("9"), y = ytemp, labels = label, srt = 90, adj = 0.5, cex = cex, xpd = TRUE)
	}
	
	for (i in c(1, 2, 9, 17)) {
		if (!(i == 2)) add_ann(side = 2, aty = i, label = if (ann && i %in% c(1, 9, 17)) paste0(16 - i + 1, "|", i - 1) else "") # Left axis
		if (i > 1) add_ann(side = 4, aty = i, label = if (ann) i - 1 else "") # Right axis
	}
	

	invisible(0)
}



plot_agreement_regional_grids <- function(ircp = 2, mask_global, mask_regions, mask_gregions, #default: ircp = 2, RCP85
								dat_cur, dat_shifts = NULL,
								cex = 1,
								mapcols,
								relArealBar = FALSE, relAgreementHist = FALSE,
								dir.out, fname) {
	
	#---Plot pdf
	h.panel <- 2.5; w.panel <- 3; w.edge <- 0.4; h.edgeL <- 0.25
	pdf(height = h.edgeL + h.panel * 2, width = w.edge + w.panel * 3, file = file.path(dir.out, fname))
	layout(matrix(c(rep(0, 1 + 2), sapply(1:3, function(x) c((x - 1)*2 + 1:2, 0))), nrow = 1 + 2, ncol = 1 + 3, byrow = FALSE), heights = c(rep(h.panel, times = 2), h.edgeL), widths = c(w.edge, rep(w.panel, times = 3)))
	op <- par(mgp = c(1, 0, 0), mar = rep(0.75, 4), tcl = 0.3, cex = cex)

	# First panel: world map with regions
	i_panel <- 1
	image(mask_global, maxpixels = ncell(mask_global), xlim = c(-125, 130), ylim = c(-40, 50), xlab = "", ylab = "", col = "white", asp = 1, cex = cex, axes = FALSE)
	axis(1, pos = -90)
	axis(2, at = c(-90, (ats <- axTicks(2))[ats >= -90 & ats <= 90], 90))
	mtext(side = 2, line = 1.2, "Latitude", cex = par("cex") * cex)
	if (fig_style == "nature") {
		mtext(side = 3, line = -0.5, adj = 0.05, cex = cex, font = 2, text = tolower(letters[i_panel]))
	} else {
		mtext(side = 3, line = -0.5, adj = 0.05, cex = cex, text = paste0("(", letters[i_panel], ")"))
	}
	if (!is.null(dat_cur) && sum(!is.na(dat_cur)) > 0) {
		grid_cur <- calc.RasterFromData(Xcoord = dLoc$X_WGS84, Ycoord = dLoc$Y_WGS84, dataVector = dat_cur, mask = mask_global)
		raster::image(grid_cur, col = mapcols$cols_cur, add = TRUE)
	}
	lapply(mask_regions[regions_n], function(x) {rct <- extent(x); rect(rct@xmin, rct@ymin, rct@xmax, rct@ymax, lwd = 1, border = "black")})
	map("world", lwd = 0.5, col = "gray30", resolution = 0, add = TRUE)
	
	# Next panels: region map with rcp agreement
	# prepare data
	i_panel <- 2
	if (!is.null(dat_shifts)) {
		# since current == const, then trailing + stable == 16
		grid_shift <- lapply(shifts, function(ish) calc.RasterFromData(Xcoord = dLoc$X_WGS84, Ycoord = dLoc$Y_WGS84, dataVector = dat_shifts[ish, ircp, ], mask = mask_global))
		grid_regions <- lapply(grid_shift, function(x) regionalize(x, mask_gregions, mask_regions, write = FALSE))
	} else {
		grid_regions <- NULL
	}

	# Relative areal contribution
	if (!relAgreementHist && relArealBar && !is.null(dat_shifts)) {
		table_area <- read.csv(file.path(dir.gtd, "Prj03_GlobalVulnerability", "4_Analysis", "4_Analysis_v4", "6_Results", "1_StudyArea", "Tables", "Table_S4_Change of global temperate dryland area relative to current geographic extent_v2.csv"), row.names = 1)
	}
	
	# Histogram insets of agreement levels
	if (relAgreementHist) {
		hist_locs <- list(c(xmin = -89, xmax = -79.5, ymin = -47, ymax = -35), #South America
							NULL,
							c(xmin = 110, xmax = 125, ymin = 22, ymax = 32), #East Asia
							c(xmin = 25, xmax = 40, ymin = 17, ymax = 33), #Central Asia
							c(xmin = 5, xmax = 10, ymin = 30.5, ymax = 34.5), #Mediterranean
							c(xmin = -125, xmax = -118, ymin = 29, ymax = 35)) #North America
	}
	
	# loop through panels and plot
	for (i in c(1, 6, 4, 5, 3)) {
		# Determine if there is something to be plotted
		if (ircp > 0) {
			do_plot_panel <- !is.null(grid_regions[[1]][[i]]) && (ncell(grid_regions[[1]][[i]]) - cellStats(grid_regions[[1]][[i]], "countNA") > 0)
		} else {
			do_plot_panel <- TRUE
		}
		
		if (do_plot_panel) {
			image(mask_regions[[i]], maxpixels = ncell(mask_regions[[i]]), xlab = "", ylab = "", col = "white", asp = 1, cex = cex, axes = FALSE)
			axis(side = 1, cex = cex)
			axis(side = 2, cex = cex)

			for (iss in seq_along(shifts)) {
				image(grid_regions[[iss]][[i]], maxpixels = ncell(grid_regions[[iss]][[i]]), col = mapcols$shifts[[iss]], zlim = c(0, length(reqGCMs)), add = TRUE)
			}

			if (fig_style == "nature") {
				mtext(side = 3, line = -0.5, adj = 0.05, cex = cex, font = 2, text = tolower(letters[i_panel]))
			} else {
				mtext(side = 3, line = -0.5, adj = 0.05, cex = cex, text = paste0("(", letters[i_panel], ")"))
			}

			ext <- par()$usr
			map("world", xlim = ext[1:2], ylim = ext[3:4], lwd = 0.5, col = "gray30", resolution = 0, add = TRUE)
			if (i == 6) map("state", xlim = ext[1:2], ylim = ext[3:4], lwd = 0.5, col = "gray30", resolution = 0, add = TRUE)
			if (i == 1 && !relAgreementHist) legend(x = "bottomleft", bty = "n", legend = capwords(shifts), pch = 15, col = mapcols$legend, cex = 1.5 * 0.75 * cex)
			if (i == 1) mtext(side = 2, line = 1.2, "Latitude", cex = par()$cex * cex)
			if (i %in% c(1, 3, 4)) mtext(side = 1, line = 0.8, "Longitude", cex = par()$cex * cex)
			
			if (!relAgreementHist && relArealBar && exists("table_area")) { # add bar indicating relative areal contribution at rank ir
				ir <- 2
				temp <- table_area[table_area$Var2 == reqRCPs[ircp] & table_area$Var3 == paste0("rank", ranks[ir]) & table_area$Var1 %in% shifts, paste0("Region", i)] 
				temp <- c(0, temp[1], 1 - temp[1], temp[2]) #shifts
				temp <- cumsum(ifelse(is.na(temp), 0, temp))
				usr <- par("usr")
				wb <- 1.5 * strwidth("999999"); hb <- 0.5 * strheight("9")
				x0 <- usr[1] + 0.15 * (usr[2] - usr[1])
				y0 <- usr[4] - 0.0 * (usr[4] - usr[3]); y1 <- y0 - hb
				for (ish in seq_along(shifts)) {
					rect(xleft = x0 + wb * temp[ish],
						xright = x0 + wb * temp[ish + 1],
						ybottom = y0, ytop = y1,
						col = cols_shifts[ish], border = cols_shifts[ish])
					if (ish %in% c(1, 3))
						segments(x0 = x0 + wb * temp[ish], x1 = x0 + wb * temp[ish], y0 = y0, y1 = y0 - 1.25 * hb, col = "black", lend = 1)
				}
				segments(x0 = x0 + wb * temp[4], x1 = x0 + wb * temp[4], y0 = y0, y1 = y0 - 1.25 * hb, col = "black", lend = 1)
				segments(x0 = x0, x1 = x0 + wb * temp[4], y0 = y1, y1 = y1, col = "black", lend = 1)
			}
			
			if (relAgreementHist) {
				ncols <- 1 + length(reqGCMs)
				if (length(mapcols$legend) == 2) {
					cols_shifts12 <- if (length(mapcols$legend[[1]]) == ncols) {
							mapcols$legend[[1]]
						} else {
							colorRampPalette(c(mapcols$legend[[1]][2], mapcols$legend[[1]][1]))(ncols)
						}
					cols_shift3 <- if (length(mapcols$legend[[2]]) == ncols) {
							mapcols$legend[[2]]
						} else {
							colorRampPalette(c(mapcols$legend[[2]][1], mapcols$legend[[2]][2]))(ncols)
						}
					lcols <- NULL
				} else {
					lcols <- mapcols$legend
					cols_shifts12 <- cols_shift3 <- NULL
				}
					

				hist_inset(dTrail = dat_shifts["trailing", reqRCPs[ircp], dLoc$Region == i],
							dStable = dat_shifts["stable", reqRCPs[ircp], dLoc$Region == i],
							dLead = dat_shifts["leading", reqRCPs[ircp], dLoc$Region == i],
							ext = hist_locs[[i]],
							cols = lcols, cols_shifts12 = cols_shifts12, cols_shift3 = cols_shift3, # cols = mapcols$legend
							ann = (i_panel == 2))
			}
			
			i_panel <- i_panel + 1
		} else {
			plot.new()
		}
	}
	
	par(op)
	dev.off()
}




draw.contourCIpoints <- function(x, y, alpha = 0.95, col = "red", fill = FALSE, na.rm = FALSE, ...) {
	#contour of alpha*100% of the points
	#https://stat.ethz.ch/pipermail/r-help/2008-June/166079.html (Pascal Haenggi, 2008)
	require(MASS)
	
	if (na.rm) {
		iuse <- complete.cases(cbind(x, y))
		x <- x[iuse]
		y <- y[iuse]
	}
	
	if (length(x) > 1 && sd(x) > 0 && sd(y) > 0) {
		xlim.plot <- c(min(x), max(x))
		ylim.plot <- c(min(y), max(y))
		
		xlim.kd <- c(min(x)*(1-sign(min(x))*1), max(x)*(1+sign(max(x))*1))
		ylim.kd <- c(min(y)*(1-sign(min(y))*1), max(y)*(1+sign(max(y))*1))
		
		bdws <- c(bandwidth.nrd(x), bandwidth.nrd(y))
		if (any(bdws) <= 0) invisible(1)
		
		n <- if (length(x) < 50 && min(bdws) < 1 && diff(range(bdws)) > 75) 10 else 100
		
		kerneld <- kde2d(x, y, n = n, h = bdws, lims = c(xlim.kd, ylim.kd))
		
		pp <- array()
		for (i in 1:length(x)) {
				z.x <- max(which(kerneld$x < x[i]))
				z.y <- max(which(kerneld$y < y[i]))
				pp[i] <- kerneld$z[z.x, z.y]
		}
		
		confidencebound <- quantile(pp, 1-alpha, na.rm = TRUE)
		
		if (fill) {
			cl <- contourLines(kerneld, levels = confidencebound)
			for (cli in seq(along = cl)) {
				polygon(x = cl[[cli]]$x, y = cl[[cli]]$y, border = NA, col = adjustcolor(col, alpha.f = 0.3), ...)
			}
		} else {
			contour(kerneld, levels = confidencebound, col = col, drawlabels = FALSE, xlim = xlim.plot, ylim = ylim.plot, add = TRUE, ...)
		}
	}
	
	invisible(0)
}



scatter_regional_response <- function(dat_curX, dat_curY, dat_ensX, dat_ensY,
								fun_ens = NULL, fun_inv_ens = NULL,
								xlab1 = "x-axis", xlab2 = "", ylab1 = "y-axis", ylab2 = "",
								xlims = NULL, xextremes = NULL, ylims = NULL, yextremes = NULL, # lists of length 4: current + 3 shifts
								val_critX = 0, val_critY = 0, 
								cex = 1, dir.out, fname) {


	#---Apply transformation to values
	if (!is.null(fun_ens)) {
		fun_ens <- match.fun(fun_ens)
		for (ircp in seq_along(reqRCPs)) {
			for (ir in seq_along(ranks)) {
				for (iss in seq_along(shifts_used)) {
					dat_ensX[ircp, ir, iss][[1]] <- fun_ens(dat_ensX[ircp, ir, iss][[1]])
					dat_ensY[ircp, ir, iss][[1]] <- fun_ens(dat_ensY[ircp, ir, iss][[1]])
				}
			}
		}
	}
	if (!is.null(fun_inv_ens)) fun_inv_ens <- match.fun(fun_inv_ens) #Prepare inverse transformation function to be used in legends
	

	#---Plot pdf
	h.panel <- 2.5; w.panel <- 3; w.edgeL <- 0.5; w.edgeR <- 0.5; h.edgeL <- 0.5; h.edgeU <- 0.3
	pdf(height = h.edgeL + h.panel * length(regions_n) + h.edgeU, width = w.edgeL + w.panel * (1 + length(reqRCPs) * length(ranks)) + w.edgeR, file = file.path(dir.out, fname))
	layout(
		matrix(c(rep(0, 1 + length(regions_n) + 1), sapply(1:(1 + length(reqRCPs) * length(ranks)), function(x) c(0, (x - 1)*length(regions_n) + 1:length(regions_n), 0)), rep(0, 1 + length(regions_n) + 1)),
			nrow = 1 + length(regions_n) + 1,
			ncol = 1 + 1 + length(reqRCPs) * length(ranks) + 1, byrow = FALSE),
		heights = c(h.edgeU, rep(h.panel, times = length(regions_n)), h.edgeL),
		widths = c(w.edgeL, rep(w.panel, times = 1 + length(reqRCPs) * length(ranks)), w.edgeR))
	op <- par(mgp = c(1, 0, 0), mar = c(0.5, 0.5, 0.5, 0.2), tcl = 0.3, cex = cex)

	for (ircp in c(0, seq_along(reqRCPs))) {
		if (ircp == 0) {# Current panels
			n_ranks <- 1
			n_shifts <- 1
			par(mar = c(0.5, 0.5, 0.5, 1))
		} else { # Ensemble x ranks panels
			n_ranks <- seq_along(ranks)
			n_shifts <- seq_along(shifts)
			par(mar = c(0.5, 0.5, 0.5, 0.2))
		}
		for (ir in n_ranks) {
			for (i in regions_n) {
				idr <- (dLoc$Region == i) # which sites belong to this region
				
				# Determine if there is something to be plotted
				if (ircp > 0) {
					do_plot_panel <- any(!is.na(dat_ensY["MetDef_ThisCond", ircp, ir, idr]))
					x_shifts <- dat_ensX[shifts, ircp, ir, idr]
					y_shifts <- dat_ensY[shifts, ircp, ir, idr]
					cols1 <- adjustcolor(c("orange", "gray40", "lightblue"), alpha.f = 0.5)
					cols2 <- c("red", "black", "blue")
				} else {
					do_plot_panel <- TRUE
					x_shifts <- matrix(rep(dat_curX[idr], n_shifts), nrow = 1, ncol = sum(idr))
					y_shifts <- matrix(rep(dat_curY[idr], n_shifts), nrow = 1, ncol = sum(idr))
					cols1 <- "gray60"
					cols2 <- "black"
				}
				
				if (do_plot_panel) {
					add <- FALSE
					# Plot points and axes
					for (iss in n_shifts) {
						if (!add) {
							# Axis annotations
							xann_diff <- !identical(xlims[[1]], xlims[[2]])
							xann <- i == tail(regions_n, n = 1)
							yann_diff <- (ircp == 1 && ir == 1 && !identical(ylims[[1]], ylims[[2]]))
							yann <- ircp == 0 || yann_diff
						
							# Plot scatter
							plot(x = x_shifts[iss, ], y = y_shifts[iss, ],
								pch = 16, cex = 0.4, col = cols1[iss],
								xlab = "", ylab = "",
								xlim = extend_range(if (ircp == 0) xlims[[1]] else xlims[[1 + ir]], fact = 1.1),
								ylim = extend_range(if (ircp == 0) ylims[[1]] else ylims[[1 + ir]], fact = 1.1),
								axes = FALSE)
							add <- TRUE

							# Decorate plot
							if (xann) mtext(side = 1, text = if (ircp > 0 && xann_diff) paste0(gsub("Change", " change", xlab2), " of ", xlab1) else xlab1, line = 1, xpd = NA)
							if (yann) mtext(side = 2, text = if (yann_diff) paste0(gsub("Change", " change", ylab2), " of\n", ylab1) else ylab1, line = 1, xpd = NA)
							temp <- axTicks(side = 1)
							if (val_critX > min(temp) && val_critX < max(temp)) {
								abline(v = val_critX, col = "gray", lwd = 1)
							}
							temp <- axTicks(side = 2)
							if (val_critY > min(temp) && val_critY < max(temp)) {
								abline(h = val_critY, col = "gray", lwd = 1)
							}
							axis(side = 1, labels = xann, xpd = NA)
							axis(side = 2, labels = yann, xpd = NA)
							if (i == regions_n[1]) {
								temp <- if (ircp == 0) currentSc else paste0(reqRCPs[ircp], ", rank ", ranks[ir])
								mtext(side = 3, text = temp, line = 0.5, font = 2, xpd = NA)
							}
							if (ircp == 0)
								mtext(side = 3, text = label.regions[i], line = -1, xpd = NA)
						}
						# Also re-draw points for first iss because abline may hide points
						points(x = x_shifts[iss, ], y = y_shifts[iss, ], pch = 16, cex = 0.4, col = cols1[iss])						
					}
									
					# Add 50%- and 95%-data cloud on top of points
					for (iss in n_shifts) {
						try(draw.contourCIpoints(x = x_shifts[iss, ], y = y_shifts[iss, ], alpha = 0.50, col = cols2[iss], fill = FALSE, na.rm = TRUE, lwd = 2), silent = TRUE)
						try(draw.contourCIpoints(x = x_shifts[iss, ], y = y_shifts[iss, ], alpha = 0.95, col = cols2[iss], fill = FALSE, na.rm = TRUE, lwd = 1), silent = TRUE)
					}				
				} else {
					plot.new()
				}
			}
		}
	}
	
	par(op)
	dev.off()
}


