################### PLOT CHANGE IN RESPONSE PER REGION ##################
#
# Daniel Schlaepfer, 2015-2016
# 
# Calculate and plot relative/absolute change in responses variables within temperate dryland areas for
# all study_areas_and_shifts/regions x RCP combinations with among-GCM variation
#	- requests 'get_precalculations' from '5a1_GTD_*.R'
#	- requests 'get_studyareaextents' from '5a1_GTD_*.R'

# Note: aggregating changes per region may not deliver desired/expected values
#	- current value = the median over current extent
#	- future change values = medians over future extent (i.e., stable + leading zones)
#	 => median(future) != median(current) + median(change)
# ==> Use absolute values instead or aggregate by region x shifts; fig_version == 7

#* Figure 2 (Duration of continuous, growing season ecological drought)
#	- Script: _5j_GTD_Prj03v4_Analysis_ChangeDensities.R_
#	- Options: `fig_version == 7 && add_bars_extent == FALSE`
#	- Output: 6_Results/9_ChangePlots_v4/Fig_MeanDensities_resResponse2_RCP85_v7f.pdf

###################################################################


#-------------------------------
#---GLOBAL SETTINGS
comp <- "dropbox"
do_changebeans <- TRUE
redo_changebeans <- FALSE
	add_bars_extent <- FALSE
fig_version <- 7# 1, Relative change: global: variation across cells;
				# 2, Relative change: by region: variation across cells;
				# 3, Relative change: by region: variation across ranks, cells aggregated as medians;
				# 4, Relative change: by shifts, vertical: variation across ranks, cells aggregated as medians, bars for each regions
				# 5, Relative change: by shifts, horizontal: variation across ranks, cells aggregated as medians, bars for each regions
				# 6, Absolute change: by shifts, horizontal: variation across ranks, cells aggregated as medians, bars for each regions
				# 7, Mean values plus current median: by shifts, horizontal: variation across ranks, cells aggregated as medians, bars for each regions


#-------------------------------
#---R packages
pkg_reqd <- c("beanplot", "RColorBrewer")
has_loaded <- sapply(pkg_reqd,
	function(lib) require(lib, character.only = TRUE, quietly = FALSE))
stopifnot(has_loaded)

#---Load data and misc. functions
if (comp %in% c("err", "eleos")) {
	dir.gtd <- "/PATH_TO_PROJECT/Product_PowellCenter/6_Projects_Year1"
} else if (comp == "dropbox") {
	dir.gtd <- "/PATH_TO_PROJECT/Product_PowellCenter/6_Projects_Year1"
}
dir.prj <- file.path(dir.gtd, "Prj03_GlobalVulnerability", "4_Analysis", "4_Analysis_v4")


get_precalculations <- TRUE
get_studyareaextents <- TRUE
source(file.path(dir.prj, "5a1_GTD_Prj03v4_Helper.R"))

stopifnot(done_precalculations, done_studyareaextents)


#---Directories
dir.create(dir.fig_SAM <- file.path(dir.prj, "6_Results", "9_ChangePlots_v4"), showWarnings = FALSE)


#-------------------------------
#------WITHIN TEXT RESULTS


#-------------------------------
#------TABLES AND FIGURES

if (do_changebeans) {
	res_names <- sets_names_extracted2[-(3:4)]
	res_names_cor <- sets_names_cor2[-(3:4)]
	var_names <- list(var_climate, var_response_sel, var_veg)
	var_labels <- list(label_climate, label_response_sel, label_veg)
	var_modsel <- list(NULL, list(Mean = c(2:3, 8:9, 4, 10), AbsoluteChange = c(2:3, 8:9, 4, 10), RelativeChange = -c(1, 5, 6, 7, 12)), NULL, NULL)
	var_modsel <- list(NULL, list(Mean = c(2:3, 8:9), AbsoluteChange = c(2:3, 8:9, 4, 10), RelativeChange = -c(1, 5, 6, 7, 12)), NULL, NULL)
	var_modsel <- list(NULL, list(Mean = c(2:3), AbsoluteChange = c(2:3, 8:9, 4, 10), RelativeChange = -c(1, 5, 6, 7, 12)), NULL, NULL)

	col_shifts <- c("firebrick3", "darkgray", "dodgerblue4")
	col_current <- "gray20"
	col_regions <- brewer.pal(5, "Set2")


	do_regional_change_beans <- function(dat, dat_current = NULL, varnames, varlabels, val_type = "RelativeChange", dir_out, ftag, add_legend = FALSE) {
#str(dat_current): num [1:3, 1:3, 1:20021, 1:nvars] 1002 NA NA 987 NA ...
# - attr(*, "dimnames") = List of 4
# ..$ : chr [1:3] "Simulation" "MetDef_Any17Cond" "MetDef_ThisCond"
# ..$ : chr [1:3] "Current" "RCP45" "RCP85"
# ..$ : NULL
# ..$ : chr [1:nvars] vars
#str(dat): str(dat)
# num [1:6, 1:2, 1:16, 1:20021, 1:nvars] 1074 NA NA NA NA ...
# - attr(*, "dimnames") = List of 5
# ..$ : chr [1:6] "Simulation" "MetDef_Any17Cond" "MetDef_ThisCond" "trailing" ...
# ..$ : chr [1:2] "RCP45" "RCP85"
# ..$ : chr [1:16] "CanESM2" "CESM1-CAM5" "CSIRO-Mk3-6-0" "EC-EARTH" ...
# ..$ : NULL
# ..$ : chr [1:nvars] vars
		
		ftag <- clean_name(ftag)
		
		for (ircp in seq_along(reqRCPs)) {
		
			ftemp <- file.path(dir_out, fname <- paste0("Fig_", val_type, "Densities_", ftag, "_", reqRCPs[ircp], "_v", fig_version, ".pdf"))
			if (redo_changebeans || !file.exists(ftemp)) {
				#---Prepare plot
				dats <- dat
				# Data
				for (iv in seq_along(varnames)) {
					dats[,,,, iv] <- dat_sweep(dat[,,,, iv], dat_current["Simulation", currentSc, , iv], val_type, circular = grepl("_doy", varnames[iv]))
				}
				
				# Areal extent
				if (add_bars_extent) {
					table_area <- read.csv(file.path(dir.gtd, "Prj03_GlobalVulnerability", "4_Analysis", "4_Analysis_v4", "6_Results", "1_StudyArea", "Tables", "Table_S3_Extent of global temperate drylands.csv"), row.names = 1)
					rel_area <- table_area[, -(1:3)] / max(table_area[1, -(1:3)])
				}				

				if (fig_version <= 6) warning("Only version 7 has been updated for code version 4")

				#-------RelativeChange
				#---Global: variation across cells
				if (fig_version == 1) {
					xlim <- c(0, 2)
					#for (ir in seq_along(ranks))
					ir <- 2
					op <- par(mar = c(4, 15, 1, 1), las = 1)
					for (iss in rev(seq_along(shifts))) {
						col1 <- mcols$cols$ranks[[ir]][iss]
						col2 <- adjustcolor(col1, alpha.f = if (iss == 2) 0.6 else 0.3)
						beanplot(data.frame(dats[shifts[iss], ircp, ir, , ]),
							at = rev(seq_along(varnames)),
							names = varlabels,
							col = c(col2, NA, col1, col1), border = NA,
							ylim = xlim, beanlines = "median", log = "",
							frame.plot = FALSE, horizontal = TRUE,
							what = c(0, 1, 1, 0), add = !(iss == 3))
					}
					mtext(side = 1, line = 2, text = "Ratio future / current")
					abline(v = 1, col = "gray")
					par(op)
				
					dev.copy2pdf(file = ftemp)
				}
				
				
				#---By region: variation across cells
				if (fig_version == 2) {
					op <- par(mfrow = c(3, 2), mar = c(4, 15, 1, 1), las = 1)
					for (i in regions_n) {
						ids <- dLoc[, "Region"] == i

						#for (ir in seq_along(ranks))
						for (iss in rev(seq_along(shifts))) {
							col1 <- mcols$cols$ranks[[ir]][iss]
							col2 <- adjustcolor(col1, alpha.f = if (iss == 2) 0.6 else 0.3)
						
							if (FALSE) boxplot(data.frame(dats[shifts[iss], ircp, ir, ids, ]),
								at = rev(seq_along(varnames)),
								names = varlabels,
								col = col2, 
								ylim = xlim, log = "",
								frame.plot = FALSE, horizontal = TRUE,
								add = !(iss == 3 && ir == 1)
							)
						
							if (TRUE) beanplot(data.frame(dats[shifts[iss], ircp, ir, ids, ]),
								at = rev(seq_along(varnames)),
								names = varlabels,
								col = c(col2, NA, col1, col1), border = NA,
								ylim = xlim, log = "", cutmin = 0, grownage = 1000, 
								beanlines = "median", lwd = ir,
								frame.plot = FALSE, horizontal = TRUE,
								what = c(0, 1, 1, 0),
								add = !(iss == 3 && ir == 1)
							)
						}
						mtext(side = 1, line = 2, text = "Ratio future / current")
						mtext(side = 3, text = label.regions[i])
						abline(v = 1, col = "gray")
					
					}
					par(op)
				
					dev.copy2pdf(file = ftemp)
				}


				#---By region: variation across ranks, cells aggregated as medians
				if (fig_version == 3) {
					xlim <- c(0, 2.5)
	
					h.panel <- 2.5; w.panel <- 3; w.edge <- 2.2; h.edgeL <- 0.25
					nrows <- 2; ncols <- 3
					cex <- 1
				
					pdf(height = h.edgeL + h.panel * nrows, width = w.edge + w.panel * ncols, file = ftemp)
					layout(matrix(c(rep(0, 1 + nrows), sapply(1:ncols, function(x) c((x - 1)*nrows + 1:nrows, 0))), nrow = 1 + nrows, ncol = 1 + ncols, byrow = FALSE),
						heights = c(rep(h.panel, times = nrows), h.edgeL),
						widths = c(w.edge, rep(w.panel, times = ncols)))
					op <- par(mgp = c(1, 0.25, 0), mar = rep(0.25, 4), tcl = 0.3, las = 1, cex = cex)
					
					i_panel <- 1
					for (i in c(0, 1, 6, 4, 5, 3)) {
						ids <- if (i == 0) rep(TRUE, times = nrow(dLoc)) else dLoc[, "Region"] == i

						for (iss in rev(seq_along(shifts))) {
							col2 <- col_shifts[iss]
							col1 <- adjustcolor(col2, alpha.f = 0.5)
						
							res <- apply(dats[shifts[iss], ircp, , ids, ], MARGIN = c(1, 3), median, na.rm = TRUE)
						
							# prepare plot
							if (iss == 3)
								plot(1, xlim = xlim, ylim = c(0, length(varnames) + 1), xlab = "", ylab = "", col = "white", axes = FALSE)
						
							# add connector
							for (iv in seq_along(varnames)) {
								halfrange <- max(0.06, min(0.25, diff(range(res[, iv], na.rm = TRUE)) / 2))
								temp <- c(if (is.na(res[1, iv])) res[2, iv] - ifelse(res[3, iv] > res[2, iv], 1, -1) * halfrange else res[1, iv],
										if (is.na(res[3, iv])) res[2, iv] + ifelse(res[2, iv] > res[1, iv], 1, -1) * halfrange else res[3, iv])
								code <- if (is.na(res[1, iv])) 1 else if (is.na(res[3, iv])) 2 else 3
								arrows(x0 = temp[1], y0 = length(varnames) - iv + 1 + (iss - 2)/6,
									x1 = temp[2],
									code = code, length = if (code == 3) 0 else 0.25/2,
									lwd = 3, col = col1)
							}
							# add medians
							for (ir in seq_along(ranks)) {
								segments(x0 = rev(res[ir, ]), y0 = seq_along(varnames) + (iss - 2)/6 - if (ir == 2) 0.4 else 0.25,
									x1 = rev(res[ir, ]), y1 = seq_along(varnames) + (iss - 2)/6 + if (ir == 2) 0.4 else 0.25,
									lwd = if (ir == 2) 3 else 2, col = col2)
							}
						}
						axis(1, pos = 0.5, labels = (i_panel %in% c(2, 4, 6)))
						axis(2, at = seq_along(varnames), labels = if (i_panel <= 2) rev(varlabels) else FALSE, cex.axis = par("cex") * cex * 0.75)
						if ((i_panel %in% c(2, 4, 6))) mtext(side = 1, line = 0, text = "Ratio future / current")
						mtext(side = 3, line = -1, text = if (i == 0) "All regions" else label.regions[i])
						mtext(side = 3, line = -1, adj = 0.05, cex = par("cex") * cex, text = paste0("(", letters[i_panel], ")"))
						segments(x0 = 1, y0 = 0.5, x1 = 1, y1 = length(varnames) + 0.5, col = "black")
						i_panel <- i_panel + 1
					}
					par(op)
				
					dev.off()
				}

				#---By shifts, vertical: variation across ranks, cells aggregated as medians, bars for each regions
				if (fig_version == 4) {
					xlim <- c(0, 2.5)
	
					h.panel <- 2.5; w.panel <- 5; w.edge <- 0.25; h.edgeL <- 1.5
					nrows <- 3; ncols <- 1
					cex <- 1
				
					pdf(height = h.edgeL + h.panel * nrows, width = w.edge + w.panel * ncols, file = ftemp)
					layout(matrix(c(rep(0, 1 + nrows), sapply(1:ncols, function(x) c((x - 1)*nrows + 1:nrows, 0))), nrow = 1 + nrows, ncol = 1 + ncols, byrow = FALSE),
						heights = c(rep(h.panel, times = nrows), h.edgeL),
						widths = c(w.edge, rep(w.panel, times = ncols)))
					op <- par(mgp = c(1, 0.25, 0), mar = c(0.25, 0, 0.25, 0), tcl = 0.3, las = 1, cex = cex)
					
					i_panel <- 1
					for (iss in seq_along(shifts)) {
						for (i in seq_along(regions_n)) {
							ids <- dLoc[, "Region"] %in% regions_n[i]
							col2 <- col_regions[i]
							col1 <- adjustcolor(col2, alpha.f = 0.5)
							jit_reg <- (i - ceiling(length(regions_n) / 2)) / (4 + length(regions_n))
						
							res <- apply(dats[shifts[iss], ircp, , ids, ], MARGIN = c(1, 3), median, na.rm = TRUE)
						
							# prepare plot
							if (i == 1)
								plot(1, ylim = xlim, xlim = c(0, length(varnames) + 0.5), xlab = "", ylab = "", col = "white", axes = FALSE)
						
							# add connector
							for (iv in seq_along(varnames)) {
								halfrange <- max(0.06, min(0.25, diff(range(res[, iv], na.rm = TRUE)) / 2))
								temp <- c(if (is.na(res[1, iv])) res[2, iv] - ifelse(res[3, iv] > res[2, iv], 1, -1) * halfrange else res[1, iv],
										if (is.na(res[3, iv])) res[2, iv] + ifelse(res[2, iv] > res[1, iv], 1, -1) * halfrange else res[3, iv])
								code <- if (is.na(res[1, iv])) 1 else if (is.na(res[3, iv])) 2 else 3
								arrows(y0 = temp[1], x0 = iv + jit_reg,
									y1 = temp[2],
									code = code, length = if (code == 3) 0 else 0.25/2,
									lwd = 3, col = col1)
							}
							# add medians
							for (ir in seq_along(ranks)) {
								segments(y0 = res[ir, ], x0 = seq_along(varnames) + jit_reg - if (ir == 2) 0.2 else 0.1,
									y1 = res[ir, ], x1 = seq_along(varnames) + jit_reg + if (ir == 2) 0.2 else 0.1,
									lwd = if (ir == 2) 3 else 2, col = col2)
							}
							
							# add legend
							if (i_panel == 3)
								legend(x = "topright", bty = "n", ncol = 2, pch = 15, legend = label.regions[regions_n], col = col_regions, pt.cex = cex * 1.5, cex = cex * 0.67)
						}
						axis(2, pos = 0.25, labels = TRUE)
						axis(1, at = seq_along(varnames), labels = FALSE, cex.axis = cex, las = 3)
						if (i_panel == 3) text(x = seq_along(varnames) + 0.25, y = -0.3, labels = gsub("duration", "duration\n", gsub("onset", "onest\n", gsub("Available", "Available\n", varlabels))), srt = 45, adj = 1, xpd = NA, cex = cex) 
						if ((i_panel %in% c(2, 4, 6))) mtext(side = 2, line = 0, text = "Ratio future / current", las = 3, cex = par("cex") * cex)
						mtext(side = 3, line = -1, adj = 0.1, cex = par("cex") * cex, text = paste0("(", letters[i_panel], ")"))
						segments(y0 = 1, x0 = 0.5, y1 = 1, x1 = length(varnames) + 0.5, col = "black")
						i_panel <- i_panel + 1
					}
					par(op)
				
					dev.off()


			}

				#---By shifts, horizontal: variation across ranks, cells aggregated as medians, bars for each regions
				if (fig_version == 5) {
					xlim <- c(0, 2.5)
	
					h.panel <- 5; w.panel <- 2.5; w.edge <- 1.6; h.edgeL <- 0.25
					nrows <- 1; ncols <- 3
					cex <- 1
				
					pdf(height = h.edgeL + h.panel * nrows, width = w.edge + w.panel * ncols, file = ftemp)
					layout(matrix(c(rep(0, 1 + nrows), sapply(1:ncols, function(x) c((x - 1)*nrows + 1:nrows, 0))), nrow = 1 + nrows, ncol = 1 + ncols, byrow = FALSE),
						heights = c(rep(h.panel, times = nrows), h.edgeL),
						widths = c(w.edge, rep(w.panel, times = ncols)))
					op <- par(mgp = c(1, 0.25, 0), mar = c(0, 0.25, 0.25, 0.25), tcl = 0.3, las = 1, cex = cex)
					
					i_panel <- 1
					for (iss in seq_along(shifts)) {
						for (i in seq_along(regions_n)) {
							ids <- dLoc[, "Region"] %in% regions_n[i]
							col2 <- col_regions[i]
							col1 <- adjustcolor(col2, alpha.f = 0.75)
							jit_reg <- (i - ceiling(length(regions_n) / 2)) / (4 + length(regions_n))
						
							res <- apply(dats[shifts[iss], ircp, , ids, ], MARGIN = c(1, 3), median, na.rm = TRUE)
						
							# prepare plot
							if (i == 1)
								plot(1, xlim = xlim, ylim = c(0, length(varnames) + 0.5), xlab = "", ylab = "", col = "white", axes = FALSE)
						
							# add connector
							for (iv in seq_along(varnames)) {
								halfrange <- max(0.06, min(0.25, diff(range(res[, iv], na.rm = TRUE)) / 2))
								temp <- c(if (is.na(res[1, iv])) res[2, iv] - ifelse(res[3, iv] > res[2, iv], 1, -1) * halfrange else res[1, iv],
										if (is.na(res[3, iv])) res[2, iv] + ifelse(res[2, iv] > res[1, iv], 1, -1) * halfrange else res[3, iv])
								code <- if (is.na(res[1, iv])) 1 else if (is.na(res[3, iv])) 2 else 3
								arrows(x0 = temp[1], y0 = length(varnames) - iv + 1 + jit_reg,
									x1 = temp[2],
									code = code, length = if (code == 3) 0 else 0.25/2,
									lwd = 3, col = col2)
							}
							# add medians
							for (ir in seq_along(ranks)) {
								segments(x0 = res[ir, ], y0 = rev(seq_along(varnames)) + jit_reg - if (ir == 2) 0.2 else 0.1,
									x1 = res[ir, ], y1 = rev(seq_along(varnames)) + jit_reg + if (ir == 2) 0.2 else 0.1,
									lwd = if (ir == 2) 3 else 2, col = col1)
							}
						}
						
						# add legend
						if (i_panel == 1)
							legend(x = -1.8, y = 0.6, bty = "n", ncol = 1, pch = 15, legend = label.regions[regions_n], col = col_regions, pt.cex = cex * 1.5, cex = cex * 0.67, xpd = NA)
						axis(1, pos = 0.5, labels = TRUE)
						if (i_panel == 1) {
							text(y = rev(seq_along(varnames)), x = -0.2, labels = gsub("duration", "duration\n", gsub("onset", "onest\n", gsub("water", "water\n", varlabels))), srt = 0, adj = 1, xpd = NA, cex = cex) 
							axis(2, pos = 0, at = seq_along(varnames), labels = FALSE, cex.axis = cex, las = 3)
						}
						mtext(side = 1, line = 0, text = paste0("Ratio future / current\n", shifts[iss], " zone"), las = 1, cex = par("cex") * cex)
						mtext(side = 3, line = -1, adj = 0.1, cex = par("cex") * cex, text = paste0("(", letters[i_panel], ")"))
						segments(x0 = 1, y0 = 0.5, x1 = 1, y1 = length(varnames) + 0.5, col = "black")
						i_panel <- i_panel + 1
					}
					par(op)
				
					dev.off()


				}


				#-------AbsoluteChange
				#---By shifts, horizontal: variation across ranks, cells aggregated as medians, bars for each regions
				if (fig_version == 6) {
					units <- unique(unlist(regmatches(varlabels, gregexpr("\\([^)]*\\)", varlabels))))
					unit_groups <- sapply(varlabels, function(x) which(sapply(units, function(u) grepl(pattern = u, x = x))))
								
					nrows <- length(units); ncols <- length(shifts)
					h.panel <- 5 * table(unit_groups) / length(unit_groups); w.panel <- 2.5; w.edge <- 1.6; h.edgeL <- c(0, 0.25)
					cex <- 1
				
					pdf(height = sum(h.edgeL) + sum(h.panel), width = w.edge + w.panel * ncols, file = ftemp)
					layout(matrix(c(rep(0, 2 * nrows), sapply(1:ncols, function(x) c({temp <- (x - 1)*nrows + 1:nrows; c(temp[1], 0, temp[2])}, 0))), nrow = 2 * nrows, ncol = 1 + ncols, byrow = FALSE),
						heights = as.vector(sapply(1:nrows, function(i) c(h.panel[i], h.edgeL[i]))),
						widths = c(w.edge, rep(w.panel, times = ncols)))
					op <- par(mgp = c(1, 0.25, 0), mar = c(0, 0.25, 0.25, 0.25), tcl = 0.3, las = 1, xpd = NA, cex = cex)
					
					i_panel <- 1
					for (iss in seq_along(shifts)) {
						for (ig in seq_along(units)) {
							xlim <- switch(EXPR = ig, c(-100, 110), c(-5, 6.5))
							for (i in seq_along(regions_n)) {
								ids <- dLoc[, "Region"] %in% regions_n[i]
								col2 <- col_regions[i]
								col1 <- adjustcolor(col2, alpha.f = 0.75)
								jit_reg <- (i - ceiling(length(regions_n) / 2)) / (4 + length(regions_n))
								igvars <- which(unit_groups == ig)
						
								res <- apply(dats[shifts[iss], ircp, , ids, igvars], MARGIN = c(1, 3), median, na.rm = TRUE)
								
						
								# prepare plot
								if (i == 1)
									plot(1, xlim = xlim, ylim = c(0, length(varnames[igvars]) + if (ig == 1) 0.5 else 0), xlab = "", ylab = "", col = "white", axes = FALSE)
						
								# add connector
								for (iv in seq_along(varnames[igvars])) {
									temp <- c(if (is.na(res[1, iv])) res[2, iv] else res[1, iv],
											if (is.na(res[3, iv])) res[2, iv] else res[3, iv])
									segments(x0 = temp[1], y0 = length(varnames[igvars]) - iv + 1 + jit_reg,
										x1 = temp[2],
										lwd = 3, col = col2)
								}
								# add medians
								for (ir in seq_along(ranks)) {
									segments(x0 = res[ir, ], y0 = rev(seq_along(varnames[igvars])) + jit_reg - if (ir == 2) 0.2 else 0.1,
										x1 = res[ir, ], y1 = rev(seq_along(varnames[igvars])) + jit_reg + if (ir == 2) 0.2 else 0.1,
										lwd = if (ir == 2) 3 else 2, col = col1)
								}
							
							}

							if (i_panel == 2) # add legend
								legend(x = -13, y = 0.6, bty = "n", ncol = 1, pch = 15, legend = label.regions[regions_n], col = col_regions, pt.cex = cex * 1.5, cex = cex * 0.67, xpd = NA)
							axis(1, pos = 0.5, labels = TRUE)
							if (i_panel <= 2) {
								text(y = rev(seq_along(varnames[igvars])), x = 1.15 * xlim[1], labels = gsub(" 0-20", "\n0-20", gsub(" >20", "\n>20", gsub("water", "water\n", varlabels[igvars]))), srt = 0, adj = 1, xpd = NA, cex = cex) 
								#axis(2, pos = xlim[1], at = seq_along(varnames[igvars]), labels = FALSE, cex.axis = cex, las = 3)
							}
							if (i_panel %in% c(2, 4, 6)) mtext(side = 1, line = 0, text = paste0("Change future - current\n", shifts[iss], " zone"), las = 1, cex = par("cex") * cex)
							if (i_panel %in% c(1, 3, 5)) mtext(side = 3, line = -1, adj = 0.1, cex = par("cex") * cex, text = paste0("(", letters[i_panel], ")"))
							segments(x0 = 0, y0 = 0.5, x1 = 0, y1 = length(varnames[igvars]) + if (ig == 1) 0.5 else 0.4, col = "black")
							i_panel <- i_panel + 1
						}
					}
					par(op)
				
					dev.off()


				}




				#-------Mean
				#---By shifts, horizontal: variation across ranks, cells aggregated as medians, bars for each regions
				if (fig_version == 7) {
					jit_reg <- function(i) -(i - ceiling((length(regions_n)) / 2)) / (1 + (length(regions_n)))

					units <- unique(unlist(regmatches(varlabels, gregexpr("\\([^)]*\\)", varlabels))))
					unit_groups <- sapply(varlabels, function(x) which(sapply(units, function(u) grepl(pattern = u, x = x, fixed = TRUE))))
					n_unit_groups <- rle(unit_groups)$lengths
					is_soils <- all(grepl("20", varlabels))
					
					horiz <- (length(units) > 1) || (length(varlabels) >= 4)
					if (horiz) {
						nrows <- length(units)
						ncols <- length(shifts)
					} else {
						nrows <- length(shifts)
						ncols <- length(units)
					}
					h.panel_default <- 4 #5
					h.panel <- h.panel_default * if (length(units) == 1) rep(length(varlabels) / 4, nrows) else table(unit_groups) / length(unit_groups)
					w.panel <- if (horiz) 2.5 else if (add_bars_extent) 4.1 else 3
					w.edge <- if (horiz) 1.6 else 0.7
					h.edgeL <- if (length(h.panel) > 1) c(rep(h.panel_default * if (horiz) 0.08 else 0.01, length(h.panel) - 1), if (is_soils) 0.4 else 0.65) else 0.65
					ylim0 <- 0.5
					cex <- 1
					d_relarea <- 0.06
					
					# Prepare data
					res <- array(NA, dim = c(length(shifts), length(units), length(reqGCMs), max(n_unit_groups), length(regions_n)))
					res_cur <- array(NA, dim = c(length(shifts), length(units), max(n_unit_groups), length(regions_n)))
					res_rank <- array(NA, dim = c(length(shifts), length(units), length(ranks), max(n_unit_groups), length(regions_n)))
					igvars <- array(list(), dim = c(length(shifts), length(units)))
					
					for (iss in seq_along(shifts)) {
						for (ig in seq_along(units)) {
							igvars[iss, ig][[1]] <- which(unit_groups == ig)
							nis <- seq_along(igvars[iss, ig][[1]])
							ishift <- apply(dats[shifts[iss], ircp, , , 1], MARGIN = 2, function(x) any(!is.na(x)))
							
							# 1) Calculate GCM x region medians
							for (i in seq_along(regions_n)) {
								ids <- dLoc[, "Region"] %in% regions_n[i]
								res[iss, ig, , nis, i] <- apply(dats[shifts[iss], ircp, , ids, ][, , nis, drop = FALSE], MARGIN = c(1, 3), median, na.rm = TRUE)
								res_cur[iss, ig, nis, i] <- apply(dat_current["Simulation", currentSc, ids & ishift, ][, nis, drop = FALSE], MARGIN = 2, median, na.rm = TRUE)
							}
							
							# 2) Rank GCMs
							res_rank[iss, ig, , nis, ] <- apply(res[iss, ig, , nis, ], 2:3, calc_ensemble4)
						}
					}
									
					# Plot
					pdf(height = sum(h.edgeL) + sum(h.panel), width = w.edge + w.panel * ncols, file = ftemp)
					layout_matrix <- matrix(c(rep(0, 2 * nrows), sapply(1:ncols, function(x) {temp <- (x - 1)*nrows + 1:nrows; tt <- rep(0, times = 2*nrows); tt[as.logical(1:(2*nrows) %% 2)] <- temp; tt})), nrow = 2 * nrows, ncol = 1 + ncols, byrow = FALSE)
					layout(layout_matrix,
						heights = as.vector(sapply(1:nrows, function(i) c(h.panel[i], h.edgeL[i] * (if (!horiz && i == nrows - 1) 2 else 1)))),
						widths = c(w.edge, rep(w.panel, times = ncols)))
					op <- par(mgp = c(1, 0.05, 0), mar = c(0, 0.25, 0.25, 0.25), tcl = 0.3, las = 1, xpd = NA, cex = cex)
					
					i_panel <- 1
					for (iss in seq_along(shifts)) {
						for (ig in seq_along(units)) {
							nis <- seq_along(igvars[iss, ig][[1]])

							xlim <- range(res_cur[, ig, , ], res_rank[, ig, , , ], na.rm = TRUE)
							xlim <- if (grepl("days", units[ig])) {
										if (min(xlim) < 0) c(-365, 365) else c(0, if (!add_bars_extent) 260 else 365)
									} else if (grepl("-", units[ig])) {
										if (min(xlim) < 0) c(-1, 1) else c(0, 1)
									} else xlim
							if (add_bars_extent) x0_relarea <- 0.8 * max(res_rank[, 1, , 1, ]) + 0.2 * xlim[2]
							
							for (i in seq_along(regions_n)) {
								col2 <- col_regions[i]
								col1 <- adjustcolor(col2, alpha.f = 0.75)
						
								# prepare plot
								if (i == 1) {
									ylim <- c(ylim0, length(nis) + if (ig == 1) 0.5 else 0)
									plot(1, xlim = xlim, ylim = ylim, xlab = "", ylab = "", col = "white", axes = FALSE)
								}
						
								# add medians
								for (ir in seq_along(ranks)) {
									if (ir == 2) {
										points(x = res_rank[iss, ig, ir, , i], y = rev(nis) + jit_reg(i), pch = 1, cex = 1.5, lwd = 3, col = col1)
									} else {
										segments(x0 = res_rank[iss, ig, ir, , i], y0 = rev(nis) + jit_reg(i) - if (ir == 2) 0.1 else 0.05,
											x1 = res_rank[iss, ig, ir, , i], y1 = rev(nis) + jit_reg(i) + if (ir == 2) 0.1 else 0.05,
											lwd = if (ir == 2) 3 else 2, col = col1)
									}
								}
								# add connector
								for (iv in nis) {
									temp <- c(if (is.na(res_rank[iss, ig, 1, iv, i])) res_rank[iss, ig, 2, iv, i] else res_rank[iss, ig, 1, iv, i],
												if (is.na(res_rank[iss, ig, 3, iv, i])) res_rank[iss, ig, 2, iv, i] else res_rank[iss, ig, 3, iv, i])
									y <- length(nis) - iv + 1 + jit_reg(i)
									segments(x0 = temp[1], y0 = y, x1 = temp[2], lwd = 3, col = col2, lend = 1)
									points(x = res_cur[iss, ig, iv, i], y = y, pch = 4, lwd = 2, col = col_current)
								}
							
								# Add relative area
								if (add_bars_extent && ig == 1) {									
									y0_relarea <- length(igvars[iss, ig][[1]]) + jit_reg(i)

									#Shifting zone
									xtemp2 <- rel_area[table_area$Var2 == reqRCPs[ircp] & table_area$Var1 == shifts[iss], paste0("Region", regions_n[i])]
									rect(xleft = xlim[2] - xtemp2[2] * (xlim[2] - x0_relarea), ybottom = y0_relarea - d_relarea,
										xright = xlim[2], ytop = y0_relarea + d_relarea, border = NA, col = cols_shifts[iss])
									arrows(x0 = xlim[2] - xtemp2[1] * (xlim[2] - x0_relarea), y0 = y0_relarea, x1 = xlim[2] - xtemp2[3] * (xlim[2] - x0_relarea), code = 3, angle = 90, length = d_relarea * 1 / 2 * par("pin")[2] / diff(par("usr")[3:4]))
									
									#Current extent
									xtemp <- rel_area[table_area$Var2 == "Current", paste0("Region", regions_n[i])]
									rect(xleft = xlim[2] - xtemp * (xlim[2] - x0_relarea), ybottom = y0_relarea - d_relarea,
										xright = xlim[2], ytop = y0_relarea + d_relarea, lwd = 0.75, border = "black", col = "transparent")
									
									# Secondary axis annotation
									if (i == 1) {
										# Add axis and ticks
										#	(x1, x0) at usr = (x0_relarea, xlim[2]) and km2 = (max(table_area[1, -(1:3)]), 0)

										at_y3 <- 0.99 * max(axTicks(2))
										at_x3_km2 <- axisTicks(usr = c(max(table_area[1, -(1:3)]), 0), log = FALSE, n = 3)
										at_x3_usr <- xlim[2] - at_x3_km2 * (xlim[2] - x0_relarea) / max(at_x3_km2) 
										segments(x0 = min(at_x3_usr), y0 = at_y3, x1 = max(at_x3_usr), lwd = 0.75, col = "black")
										segments(x0 = at_x3_usr, y0 = at_y3, x1 = at_x3_usr, y1 = at_y3 - d_relarea, lwd = 0.75, col = "black")
										
										# Add labels at last panel
										if (iss == length(shifts)) {
											text(x = at_x3_usr, y = at_y3, labels = at_x3_km2, adj = c(0.5, -0.3), las = 1, cex = 0.65)
											mtext(side = 3, line = -0.15, adj = 0.825, cex = 0.65, text = expression(paste("Extent (", km^2, ")")))
										}
									}
								}
							}
							

							# Add annotations
							if (!identical(fig_style, "nature")) {
								if (length(units) > 1) {
									if (i_panel == tail(layout_matrix, n = 2)[1, 2]) { # add legend
										usr <- par()$usr
										legend(x = usr[1] - 2/3 * (usr[2] - usr[1]), y = 0.8, bty = "n", ncol = 1, pch = c(4, rep(15, length(regions_n))), legend = c("Current", label.regions[regions_n]), col = c(col_current, col_regions), pt.cex = cex * 1.5, pt.lwd = 2, cex = cex * 0.67, xpd = NA)
									}
								} else {
									if (i_panel == length(ranks)) {
										legend(x = "topright", bty = "n", ncol = 1, pch = c(4, rep(15, length(regions_n))), legend = c("Current", label.regions[regions_n]), col = c(col_current, col_regions), pt.cex = cex * 1.5, pt.lwd = 2, cex = cex * 0.67, xpd = NA)
									}
								}
							}
							xtemp <- min(xlim[1], axTicks(1))
							axis(1, pos = ylim[1], labels = (horiz || i_panel == max(layout_matrix)))
							xlab_temp <- ""
							if (i_panel <= max(layout_matrix[, 2])) {
								ylab_temp <- gsub(" 0-20", "\n0-20", gsub(" >20", "\n>20", gsub("water", "water\n", varlabels[igvars[iss, ig][[1]]])))
								if (length(units) == 1) ylab_temp <- gsub(paste0(" ", units), "", ylab_temp, fixed = TRUE)
								if (!horiz && is_soils) {
									xlab_temp <- paste(strsplit(ylab_temp[1], "\n0-20")[[1]][1], units)
									ylab_temp <- paste("Soil layers\n", c("0-20 cm", "> 20 cm"))
								}
								text(y = rev(nis), x = xlim[1] - 0.025 * diff(range(xlim)), labels = ylab_temp, srt = 0, adj = 1, xpd = NA, cex = cex) 
								axis(2, pos = xtemp, at = nis, labels = FALSE, cex.axis = cex, las = 3)
							}
							if (i_panel %in% tail(layout_matrix, n = 2)) {
								x0 <- mean(range(axTicks(side = 1)))
								y0 <- ylim[1] - 2.25 * par("cex") * cex * strheight("9")
								if (horiz || nchar(xlab_temp) == 0) {
									xlab <- paste0("Current and future medians\n", if (horiz) shifts[iss], if (horiz) " zone ", if (length(units) == 1) units)
								} else {
									xlab <- xlab_temp
								}
								text(x = x0, y = y0, labels = xlab, adj = c(0.5, 1), las = 1, cex = par("cex") * cex)
							}
							if (!horiz || i_panel %in% layout_matrix[1, ]) {
								if (fig_style == "nature") {
									mtext(side = 3, line = -1, adj = -0.025, cex = par("cex") * cex, font = 2, text = tolower(letters[iss]))
								} else {
									mtext(side = 3, line = -1, adj = -0.1, cex = par("cex") * cex, text = paste0("(", letters[iss], ")"))
								}
							}
							segments(x0 = xtemp, y0 = ylim[1], x1 = xtemp, y1 = length(nis) + if (ig == 1) 0.5 else 0.4, col = "black")
							if (add_legend && i_panel == max(layout_matrix)) {
								legend(x = "topright", bty = "n", legend = label.regions[regions_n], cex = 0.6 * cex, col = col_regions, lwd = 2, xpd = NA)
							}
							i_panel <- i_panel + 1
						}
					}
					par(op)
				
					dev.off()
				}
			}
		}

		invisible(NULL)
	}



	print("DrylandResponse: change plot densities")
	val_type <- change_types[switch(EXPR = fig_version, 3, 3, 3, 3, 3, 2, 1)]
	
#	for (id in seq_along(res_names)) {
if (TRUE) {
id <- 2
add_legend <- TRUE
		
		dir.temp <- dir.fig_SAM
	
		# get data objects
		temp <- fix_var_dim(get(res_names[id]))
		data <- temp$data[, -1, -1, , ]
		vars <- temp$vars
		data_current <- temp$data[study_areas_all, , currentSc, , ]
		if (length(dim(data_current)) <= 3) {
			dimns <- dimnames(data_current)
			dim(data_current) <- c(dim(data_current), 1)
			dimnames(data_current) <- modifyList(dimns, list(vars = vars))
		}
		rm(temp)
		
		# select variables and cells
		varnames <- var_names[[id]]
		varlabels <- var_labels[[id]]
		if (!is.null(var_modsel[[id]][[val_type]])) {
			varnames <- varnames[var_modsel[[id]][[val_type]]]
			varlabels <- varlabels[var_modsel[[id]][[val_type]]]
		}
		ivars <- sapply(varnames, function(x) grep(x, vars)[1])
		stopifnot(!is.na(ivars))
		data <- data[,,, , ivars]
		data_current <- data_current[,,, ivars]
	
		print(paste(Sys.time(), res_names[id]))
	
		do_regional_change_beans(dat = data,
					dat_current = data_current,
					varnames = varnames,
					varlabels = varlabels,
					val_type = val_type,
					dir_out = dir.temp, ftag = res_names[id], add_legend = add_legend)

	}
}
